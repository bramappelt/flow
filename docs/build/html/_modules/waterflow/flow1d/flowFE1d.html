

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>waterflow.flow1d.flowFE1d &mdash; Flow v1.0 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../../../_static/drop.bmp"/>
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> Flow
          

          
            
            <img src="../../../_static/drop.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">flow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">Symbol Glossary</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Flow</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>waterflow.flow1d.flowFE1d</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for waterflow.flow1d.flowFE1d</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; One dimensional finite elements flow module &quot;&quot;&quot;</span>


<span class="kn">from</span> <span class="nn">inspect</span> <span class="k">import</span> <span class="n">signature</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">deepcopy</span>
<span class="kn">import</span> <span class="nn">time</span> <span class="k">as</span> <span class="nn">Time</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="k">import</span> <span class="n">legendre</span>

<span class="kn">from</span> <span class="nn">waterflow</span> <span class="k">import</span> <span class="n">OUTPUT_DIR</span>


<div class="viewcode-block" id="Flow1DFE"><a class="viewcode-back" href="../../../waterflow.flow1d.html#waterflow.flow1d.flowFE1d.Flow1DFE">[docs]</a><span class="k">class</span> <span class="nc">Flow1DFE</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Class for solving flow problems numerically</span>

<span class="sd">    This class represents an object that can be used to solve</span>
<span class="sd">    (un)saturated 1-dimensional flow problems using finite elements.</span>
<span class="sd">    To increase the accuracy of numerical solutions the Gaussian</span>
<span class="sd">    quadrature method is used for integration approximation.</span>

<span class="sd">    Most of the methods applied on the object will change its internal</span>
<span class="sd">    state rather than returning a value. The change of the system is</span>
<span class="sd">    saved in any of its public attributes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    id_ : `str`</span>
<span class="sd">        Name of the model object.</span>

<span class="sd">    savepath : `str`, default is :py:data:`~waterflow.OUTPUT_DIR`</span>
<span class="sd">        Directory to which model runs will be saved.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    id_ : `str`</span>
<span class="sd">        Name of the model object.</span>

<span class="sd">    savepath: `str`, default is :py:data:`~waterflow.OUTPUT_DIR`</span>
<span class="sd">        Directory to which model runs will be saved.</span>

<span class="sd">    systemfluxfunc : `function`</span>
<span class="sd">        Holds the selected flux function.</span>

<span class="sd">    nodes : `numpy.ndarray`</span>
<span class="sd">        Nodal positions at which the system will be solved. Matrix of dimension</span>
<span class="sd">        :math:`[1 \\times N]`.</span>

<span class="sd">    states : `numpy.ndarray`</span>
<span class="sd">        State solutions at the nodal positions as defined in :py:attr:`~nodes`.</span>
<span class="sd">        Matrix of dimension :math:`[1 \\times N]`.</span>

<span class="sd">    seg_lengths : `numpy.ndarray`</span>
<span class="sd">        Lengths of segments between the nodes in the shape</span>
<span class="sd">        :math:`[1 \\times N - 1]`.</span>

<span class="sd">    lengths : `numpy.ndarray`</span>
<span class="sd">        The same data as in :py:attr:`~seg_lengths` but in a different</span>
<span class="sd">        representation. This representation has the shape</span>
<span class="sd">        :math:`[1 \\times N]`. This is more convenient for static</span>
<span class="sd">        state independent spatial forcing calculations.</span>

<span class="sd">    coefmatr : `numpy.ndarray`</span>
<span class="sd">        Square jacobian matrix used in the finite elements solution procedure.</span>
<span class="sd">        The exact dimension of the matrix is :math:`N \\times N`.</span>

<span class="sd">    BCs : `dict`</span>
<span class="sd">        This contains the system&#39;s boundary conditions. The keys that indicate</span>
<span class="sd">        the positions are &quot;west&quot; and &quot;east&quot;. The corresponding values have the</span>
<span class="sd">        following format:</span>

<span class="sd">        * (boundary_condition_value, type, domain_index).</span>

<span class="sd">    pointflux : `dict`</span>
<span class="sd">        Contains the scalar point fluxes on the model domain. The key : value</span>
<span class="sd">        pairs in the dictionary have the following format:</span>

<span class="sd">            &#39;Flux name&#39; : [:math:`F_{local}` of shape :math:`[1 \\times N]`]</span>

<span class="sd">    Spointflux : `dict`</span>
<span class="sd">        Contains state dependent point flux functions on the model domain. The</span>
<span class="sd">        key : value pairs in the dictionary have the following format:</span>

<span class="sd">            &#39;Flux name&#39; : [(:math:`P`, (:math:`x_{l}`, :math:`x_{r}`, :math:`lfac`, :math:`rfac`)), :math:`F_{local}` of shape :math:`[1 \\times N]`]</span>

<span class="sd">    spatflux : `dict`</span>
<span class="sd">        Contains the spatial fluxes on the model domain. Both the scalar and</span>
<span class="sd">        the calculated position dependent spatial flux function values. The</span>
<span class="sd">        key : value pairs in the dictionary have the following format:</span>

<span class="sd">            name : [:math:`F_{local}` of shape :math:`[1 \\times N]`]</span>

<span class="sd">    Sspatflux : `dict`</span>
<span class="sd">        Contains state dependent spatial fluxes on the model domain. The key :</span>
<span class="sd">        value pairs in the dictionary have the following format:</span>

<span class="sd">            name : [:math:`S`, :math:`F_{local}` of shape :math:`[1 \\times N]`]</span>

<span class="sd">    internal_forcing : `dict`</span>
<span class="sd">        The internal forcing of the system as calculated with</span>
<span class="sd">        :py:attr:`~_internal_forcing`, using the selected Gaussian quadrature</span>
<span class="sd">        :py:attr:`~gauss_degree`.</span>

<span class="sd">    forcing : `numpy.ndarray`</span>
<span class="sd">        All the forcing fluxes applied to the system including the storage</span>
<span class="sd">        change forcing. This is the matrix that will be used for the</span>
<span class="sd">        Newton-Raphson solving procedure. The dimension of this matrix is</span>
<span class="sd">        :math:`[1 \\times N]`.</span>

<span class="sd">    conductivities : `numpy.ndarray`</span>
<span class="sd">        Hydraulic conductivities at the nodal positions, :py:attr:`~nodes`.</span>
<span class="sd">        These values are calculated with the conductivity function as</span>
<span class="sd">        given in :py:attr:`~systemfluxfunc`. Matrix of dimension</span>
<span class="sd">        :math:`[1 \\times N]`.</span>

<span class="sd">    moisture : `numpy.ndarray`</span>
<span class="sd">        Moisture contents at the nodal positions, :py:attr:`~nodes`. These</span>
<span class="sd">        values are calculated with a function that should be assigned to the</span>
<span class="sd">        model explicitly, having :py:attr:`~tfun` as attribute name. Matrix of</span>
<span class="sd">        dimension :math:`[1 \\times N]`.</span>

<span class="sd">    fluxes : `numpy.ndarray`</span>
<span class="sd">        Fluxes through the :py:attr:`~nodes`, defined to be positive to the</span>
<span class="sd">        right. Matrix of dimension :math:`[1 \\times N]`.</span>

<span class="sd">    isinitial : `bool`, default is True</span>
<span class="sd">        First object that contains initial input which has not been solved for</span>
<span class="sd">        yet. This attribute is set to ``False`` when the model object has been</span>
<span class="sd">        solved for.</span>

<span class="sd">    isconverged : `bool`, default is False</span>
<span class="sd">        The system has converged to a solution.</span>

<span class="sd">    solve_data : `dict`</span>
<span class="sd">        Holds the solve information of the system including the following</span>
<span class="sd">        key : value pairs:</span>

<span class="sd">        * solved_objects - A `list` of Flow1DFE objects at solved time steps.</span>

<span class="sd">        * time - A `list` of times at which the model states are calculated.</span>

<span class="sd">        * dt - A `list` of time step sizes between consecutive model solutions.</span>

<span class="sd">        * | iter - A `list` containing the number of iterations needed for</span>
<span class="sd">          | consecutive model solutions to converge.</span>

<span class="sd">    runtime : `float`</span>
<span class="sd">        The total time (s) it takes for :py:meth:`~solve` to find a solution.</span>

<span class="sd">    df_states : `pandas.core.frame.DataFrame`</span>
<span class="sd">        Current information about the static model solution.</span>

<span class="sd">    df_balance : `pandas.core.frame.DataFrame`</span>
<span class="sd">        Current static information about the water balance.</span>

<span class="sd">    df_balance_summary : `pandas.core.frame.DataFrame`</span>
<span class="sd">        Sum of the (relevant) columns as saved in :py:attr:`~df_balance`.</span>

<span class="sd">    dft_solved_times : `pandas.core.frame.DataFrame`</span>
<span class="sd">        Dataframe version of :py:attr:`~solve_data`.</span>

<span class="sd">    dft_print_times : `pandas.core.frame.DataFrame`</span>
<span class="sd">        A version of :py:attr:`~dft_solved_times` but at specifically</span>
<span class="sd">        chosen print times. This attribute is calculated with</span>
<span class="sd">        :py:meth:`~transient_dataframeify` giving it a</span>
<span class="sd">        value for ``print_times``, otherwise the default</span>
<span class="sd">        :py:attr:`~dft_solved_times` will be used.</span>

<span class="sd">    dft_states : `dict`</span>
<span class="sd">        Collection of all :py:attr:`~df_states` dataframes for the times in</span>
<span class="sd">        :py:attr:`~dft_solved_times` or at :py:attr:`~dft_print_times` if</span>
<span class="sd">        specific print times were given.</span>

<span class="sd">    dft_nodes : `dict`</span>
<span class="sd">        Nodes that are selected in :py:meth:`~transient_dataframeify` are</span>
<span class="sd">        saved at :py:attr:`~dft_solved_times` or at :py:attr:`~dft_print_times`</span>
<span class="sd">        if specific print times were given.</span>

<span class="sd">    dft_balance : `dict`</span>
<span class="sd">        Collection of all :py:attr:`~df_balance` dataframes at</span>
<span class="sd">        :py:attr:`~dft_solved_times` or at :py:attr:`~dft_print_times` if</span>
<span class="sd">        specific print times were given.</span>

<span class="sd">    dft_balance_summary : `pandas.core.frame.DataFrame`</span>
<span class="sd">        Collection of all :py:attr:`~df_balance_summary` dataframes at</span>
<span class="sd">        :py:attr:`~dft_solved_times` or at :py:attr:`~dft_print_times` if</span>
<span class="sd">        specific print times were given.</span>

<span class="sd">    _west : `int`</span>
<span class="sd">        Internal value that differentiates between a Dirichlet or Neumann</span>
<span class="sd">        boundary condition on the western side of the domain.</span>

<span class="sd">    _east : `int`</span>
<span class="sd">        Internal value that differentiates between a Dirichlet or Neumann</span>
<span class="sd">        boundary condition on the eastern side of the domain.</span>

<span class="sd">    _delta : `float`</span>
<span class="sd">        Fixed value used for the finite displacement in the derivatives of the</span>
<span class="sd">        jacobian matrix, :py:attr:`~coefmatr`. This value may be changed</span>
<span class="sd">        manually for extremeley steep gradients.</span>

<span class="sd">    gauss_degree : `int`</span>
<span class="sd">        Degree or number of points used in the Gaussian quadrature procedure</span>
<span class="sd">        for integral approximation.</span>

<span class="sd">    _xgauss : `tuple`</span>
<span class="sd">        Roots of Legendre polynomial on the interval :math:`[0, 1]` for the</span>
<span class="sd">        selected :py:attr:`~gauss_degree`.</span>

<span class="sd">    _wgauss : `tuple`</span>
<span class="sd">        Weights that correspond to the positions in :py:attr:`~_xgauss`.</span>

<span class="sd">    gaussquad : `list`</span>
<span class="sd">        Combination of corresponding values of :py:attr:`~_xgauss` and</span>
<span class="sd">        :py:attr:`~wgauss` into a single data structure.</span>

<span class="sd">    xintegration : `list`</span>
<span class="sd">        Absolute positions of the Gaussian quadrature points in the domain</span>
<span class="sd">        :py:attr:`~nodes`. The shape of this list is</span>
<span class="sd">        :math:`[\\Lambda \\times N-1]`.</span>

<span class="sd">    summarystring : `str`</span>
<span class="sd">        Model information obtained by :py:meth:`~summary`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id_</span><span class="p">,</span> <span class="n">savepath</span><span class="o">=</span><span class="n">OUTPUT_DIR</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id_</span> <span class="o">=</span> <span class="n">id_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">savepath</span> <span class="o">=</span> <span class="n">savepath</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">systemfluxfunc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seg_lenghts</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lengths</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coefmatr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BCs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pointflux</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatflux</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Spointflux</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Sspatflux</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">internal_forcing</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conductivities</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moisture</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isinitial</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isconverged</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solve_data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">runtime</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">summarystring</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="c1"># dataframes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_states</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_balance</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_balance_summary</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dft_solved_times</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dft_print_times</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dft_states</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dft_nodes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dft_balance</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dft_balance_summary</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># private attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_west</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_east</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_delta</span> <span class="o">=</span> <span class="mf">1e-5</span>
        <span class="c1"># Gauss specific</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gauss_degree</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xgauss</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wgauss</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gaussquad</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xintegration</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="Flow1DFE.__repr__"><a class="viewcode-back" href="../../../waterflow.flow1d.html#waterflow.flow1d.flowFE1d.Flow1DFE.__repr__">[docs]</a>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Representation of the object as shown to the user &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;Flow1DFE(&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id_</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span></div>

<div class="viewcode-block" id="Flow1DFE.summary"><a class="viewcode-back" href="../../../waterflow.flow1d.html#waterflow.flow1d.flowFE1d.Flow1DFE.summary">[docs]</a>    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Description of the object</span>

<span class="sd">        Subsequent calls will update the model description if</span>
<span class="sd">        adaptations to the model were made.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        show : `bool`, default is True</span>
<span class="sd">            Print object description to the console.</span>
<span class="sd">        save : `bool`, default is False</span>
<span class="sd">            Save object description to disk.</span>
<span class="sd">        path : `str`, default is None</span>
<span class="sd">            Full path of a directory to which will be saved. This</span>
<span class="sd">            argument is mandatory if ``save=True``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The description of the model is saved as :py:attr:`~id_` with a`.txt`</span>
<span class="sd">        extension. The string version of the description is also available via</span>
<span class="sd">        :py:attr:`~summarystring`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from waterflow.flow1d.flowFE1d import Flow1DFE</span>
<span class="sd">        &gt;&gt;&gt; from waterflow.utility import conductivityfunctions as condf</span>
<span class="sd">        &gt;&gt;&gt; from waterflow.utility import fluxfunctions as fluxf</span>
<span class="sd">        &gt;&gt;&gt; from waterflow.utility.helper import initializer</span>

<span class="sd">        Select soil 13, &#39;loam&#39;, from De Staringreeks :cite:`Wosten2001`</span>
<span class="sd">        and prepare the conductivity function and theta-h relation with the</span>
<span class="sd">        soil parameters. These functions are the arguments to the fluxfunction</span>
<span class="sd">        and the storage change function respectively.</span>

<span class="sd">        &gt;&gt;&gt; s, *_ = condf.soilselector([13])[0]</span>
<span class="sd">        &gt;&gt;&gt; theta_h = initializer(condf.VG_pressureh, theta_r=s.t_res,</span>
<span class="sd">        ...                       theta_s=s.t_sat, a=s.alpha, n=s.n)</span>
<span class="sd">        &gt;&gt;&gt; kfun = initializer(condf.VG_conductivity, ksat=s.ksat, a=s.alpha, n=s.n)</span>
<span class="sd">        &gt;&gt;&gt; storage_change = initializer(fluxf.storage_change, fun=theta_h)</span>

<span class="sd">        &gt;&gt;&gt; FE = Flow1DFE(&quot;static df_states dataframe&quot;)</span>
<span class="sd">        &gt;&gt;&gt; FE.set_field1d(nodes=(-10, 0, 11))</span>
<span class="sd">        &gt;&gt;&gt; FE.set_systemfluxfunction(fluxf.richards_equation, kfun=kfun)</span>
<span class="sd">        &gt;&gt;&gt; FE.add_dirichlet_BC(0.0, &#39;west&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # Constant boundary flow of 0.3 cm/d out of the system</span>
<span class="sd">        &gt;&gt;&gt; FE.add_neumann_BC(-0.3, &#39;east&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # theta_h add manually to be included in the dataframe</span>
<span class="sd">        &gt;&gt;&gt; FE.tfun = theta_h</span>
<span class="sd">        &gt;&gt;&gt; # add spatial flux</span>
<span class="sd">        &gt;&gt;&gt; FE.add_spatialflux(-0.001, &#39;extraction&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # Add storage change function</span>
<span class="sd">        &gt;&gt;&gt; FE.add_spatialflux(storage_change)</span>
<span class="sd">        &gt;&gt;&gt; # Solve the system for one time step (dt=0.01 d)</span>
<span class="sd">        &gt;&gt;&gt; iters = FE.dt_solve(dt=0.01)</span>
<span class="sd">        &gt;&gt;&gt; FE.summary()</span>
<span class="sd">        Id: static df_states dataframe</span>
<span class="sd">        System length: 10.0</span>
<span class="sd">        Number of nodes: 11</span>
<span class="sd">        Gauss degree: 1</span>
<span class="sd">        kfun: VG_conductivity</span>
<span class="sd">        tfun: VG_pressureh</span>
<span class="sd">        BCs: west value: 0.0 and of type Dirichlet, east value: -0.3 and of type Neumann</span>
<span class="sd">        Spatflux: extraction, storage_change</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        spat-extraction   -1.000000e-02</span>
<span class="sd">        storage_change     1.255148e+00</span>
<span class="sd">        internal          -1.255148e+00</span>
<span class="sd">        all-spatial       -1.000000e-02</span>
<span class="sd">        all-points         0.000000e+00</span>
<span class="sd">        all-external      -1.000000e-02</span>
<span class="sd">        net                1.716294e-12</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># build key : value pairs where data is available</span>
        <span class="n">id_</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{self.id_}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">len_</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">num_nodes</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">len_</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">num_nodes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">degree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gauss_degree</span>
        <span class="n">bcs</span> <span class="o">=</span> <span class="p">[[</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">BCs</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">BCs</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">BCs</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
        <span class="n">bcs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> value: </span><span class="si">{}</span><span class="s2"> and of type </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">bc</span><span class="p">)</span> <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcs</span><span class="p">]</span>
        <span class="n">bcs</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">bcs</span><span class="p">)</span>
        <span class="n">pkeys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointflux</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Spointflux</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">skeys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatflux</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sspatflux</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">pointflux</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pkeys</span><span class="p">)</span>
        <span class="n">spatflux</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">skeys</span><span class="p">)</span>
        <span class="n">runtime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">runtime</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;kfun&#39;</span><span class="p">):</span>
            <span class="n">kfun</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kfun</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kfun</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;tfun&#39;</span><span class="p">):</span>
            <span class="n">tfun</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfun</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tfun</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">k</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Id&#39;</span><span class="p">,</span> <span class="s1">&#39;System length&#39;</span><span class="p">,</span> <span class="s1">&#39;Number of nodes&#39;</span><span class="p">,</span> <span class="s1">&#39;Gauss degree&#39;</span><span class="p">,</span>
             <span class="s1">&#39;kfun&#39;</span><span class="p">,</span> <span class="s1">&#39;tfun&#39;</span><span class="p">,</span> <span class="s1">&#39;BCs&#39;</span><span class="p">,</span> <span class="s1">&#39;Pointflux&#39;</span><span class="p">,</span> <span class="s1">&#39;Spatflux&#39;</span><span class="p">,</span> <span class="s1">&#39;Runtime (s)&#39;</span><span class="p">]</span>
        <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">id_</span><span class="p">,</span> <span class="n">len_</span><span class="p">,</span> <span class="n">num_nodes</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="n">kfun</span><span class="p">,</span> <span class="n">tfun</span><span class="p">,</span> <span class="n">bcs</span><span class="p">,</span> <span class="n">pointflux</span><span class="p">,</span>
             <span class="n">spatflux</span><span class="p">,</span> <span class="n">runtime</span><span class="p">)</span>

        <span class="c1"># build summary string</span>
        <span class="n">sumstring</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">sumstring</span> <span class="o">+=</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{i}</span><span class="s2">: </span><span class="si">{j}</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calcbalance</span><span class="p">()</span>
            <span class="n">sumstring</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">df_balance_summary</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># print to console</span>
        <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sumstring</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

        <span class="c1"># save to disk</span>
        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

            <span class="n">fname</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{self.id_}</span><span class="s2">.txt&quot;</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">fname</span><span class="p">),</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fw</span><span class="p">:</span>
                <span class="n">fw</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">sumstring</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">summarystring</span> <span class="o">=</span> <span class="n">sumstring</span></div>

<div class="viewcode-block" id="Flow1DFE.set_gaussian_quadrature"><a class="viewcode-back" href="../../../waterflow.flow1d.html#waterflow.flow1d.flowFE1d.Flow1DFE.set_gaussian_quadrature">[docs]</a>    <span class="k">def</span> <span class="nf">set_gaussian_quadrature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculates Gaussian quadrature roots and weights</span>

<span class="sd">        The values calculated with this method are stored in the object&#39;s</span>
<span class="sd">        :py:attr:`~_xgauss` and :py:attr:`~_wgauss` attributes. The absolute</span>
<span class="sd">        positions of the Gaussian quadrature points in the domain are</span>
<span class="sd">        calculated and saved in :py:attr:`~xintegration`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        degree : `int`, default is 1</span>
<span class="sd">            Number of points used in the Gaussian quadrature procedure.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The integration points :math:`p_{\\lambda}` for the Gaussian</span>
<span class="sd">        quadrature method are obtained by finding the roots of the Legendre</span>
<span class="sd">        polynomial of degree :math:`\\Lambda`.</span>

<span class="sd">        .. math::</span>
<span class="sd">            P_{\\Lambda}(p) = \\text{Legendre polynomials of degree $\\Lambda$}</span>

<span class="sd">        The corresponding weights :math:`w_{\\lambda}` are calculated with the</span>
<span class="sd">        following closed form equation.</span>

<span class="sd">        .. math::</span>
<span class="sd">            w_{\\lambda} = \\frac{2}{\\left(\\left(1 - p_{\\lambda}^{2}\\right) *</span>
<span class="sd">            P_{\\Lambda}^{&#39;}(p_{\\lambda})^{2}\\right)}</span>

<span class="sd">        A full description of the theory behind this Gaussain quadrature method</span>
<span class="sd">        is documented in :cite:`Abramowitz1972`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from waterflow.flow1d.flowFE1d import Flow1DFE</span>
<span class="sd">        &gt;&gt;&gt; FE = Flow1DFE(&quot;Gaussian quadrature&quot;)</span>
<span class="sd">        &gt;&gt;&gt; FE.set_field1d((-10, 0, 11))</span>
<span class="sd">        &gt;&gt;&gt; FE.set_gaussian_quadrature(2)</span>
<span class="sd">        &gt;&gt;&gt; # positions</span>
<span class="sd">        &gt;&gt;&gt; FE._xgauss</span>
<span class="sd">        (0.21132486540518708, 0.7886751345948129)</span>
<span class="sd">        &gt;&gt;&gt; # weights</span>
<span class="sd">        &gt;&gt;&gt; FE._wgauss</span>
<span class="sd">        (0.4999999999999999, 0.5000000000000002)</span>
<span class="sd">        &gt;&gt;&gt; # check shape of xintegration</span>
<span class="sd">        &gt;&gt;&gt; np.array(FE.xintegration).shape</span>
<span class="sd">        (10, 2)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># calculate roots of Legendre polynomial for degree n</span>
        <span class="n">legn</span> <span class="o">=</span> <span class="n">legendre</span><span class="p">(</span><span class="n">degree</span><span class="p">)</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">legn</span><span class="o">.</span><span class="n">r</span><span class="p">)</span>

        <span class="c1"># calculate corresponding weights</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">roots</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">legn</span><span class="o">.</span><span class="n">deriv</span><span class="p">()(</span><span class="n">roots</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># shift roots and weights from domain [-1, 1] to [0, 1]</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">roots</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">weights</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Calculate absolute positions of Gaussian quadrature roots</span>
        <span class="n">xintegration</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">roots</span><span class="p">)):</span>
                <span class="n">xij</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">roots</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> \
                       <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">xintegration</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xij</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_xgauss</span> <span class="o">=</span> <span class="n">roots</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wgauss</span> <span class="o">=</span> <span class="n">weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gaussquad</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_xgauss</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wgauss</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xintegration</span> <span class="o">=</span> <span class="n">xintegration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gauss_degree</span> <span class="o">=</span> <span class="n">degree</span></div>

<div class="viewcode-block" id="Flow1DFE._aggregate_forcing"><a class="viewcode-back" href="../../../waterflow.flow1d.html#waterflow.flow1d.flowFE1d.Flow1DFE._aggregate_forcing">[docs]</a>    <span class="k">def</span> <span class="nf">_aggregate_forcing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Aggregation of state independent forcing</span>

<span class="sd">        The state independent forcing saved in :py:attr:`~pointflux` and</span>
<span class="sd">        :py:attr:`~spatflux` is accumulated into one matrix :math:`F_{forcing}`</span>
<span class="sd">        and is saved as :py:attr:`~forcing` in the object. In the case of a</span>
<span class="sd">        Neumann boundary condition, the value of this flux is added to</span>
<span class="sd">        either the left or the right side of the domain.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from waterflow.flow1d.flowFE1d import Flow1DFE</span>
<span class="sd">        &gt;&gt;&gt; FE = Flow1DFE(&quot;Calculate water balance&quot;)</span>
<span class="sd">        &gt;&gt;&gt; FE.set_field1d(nodes=(-10, 0, 11))</span>
<span class="sd">        &gt;&gt;&gt; FE.add_dirichlet_BC(0.0, &#39;west&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # Constant boundary flow of 0.3 cm/d out of the system</span>
<span class="sd">        &gt;&gt;&gt; FE.add_neumann_BC(-0.3, &#39;east&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # Add spatial extraction of -0.001 cm/d</span>
<span class="sd">        &gt;&gt;&gt; FE.add_spatialflux(-0.001, &#39;extraction&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # add a point extraction of -0.05 cm/d at 5.5 cm depth</span>
<span class="sd">        &gt;&gt;&gt; FE.add_pointflux(-0.05, -5.5, &#39;sink&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # Aggregate state independent forcing and account for Neumann BC</span>
<span class="sd">        &gt;&gt;&gt; FE._aggregate_forcing()</span>
<span class="sd">        &gt;&gt;&gt; FE.forcing</span>
<span class="sd">        array([-0.0005, -0.001 , -0.001 , -0.001 , -0.026 , -0.026 , -0.001 ,</span>
<span class="sd">               -0.001 , -0.001 , -0.001 , -0.3005])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">))</span>
        <span class="c1"># aggregate state independent forcing</span>
        <span class="k">for</span> <span class="n">flux</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pointflux</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatflux</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">flux</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span> <span class="o">+=</span> <span class="n">flux</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># add boundaries of type neumann</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">BCs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">val</span><span class="p">,</span> <span class="n">type_</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BCs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">type_</span> <span class="o">==</span> <span class="s2">&quot;Neumann&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">val</span></div>

<div class="viewcode-block" id="Flow1DFE._internal_forcing"><a class="viewcode-back" href="../../../waterflow.flow1d.html#waterflow.flow1d.flowFE1d.Flow1DFE._internal_forcing">[docs]</a>    <span class="k">def</span> <span class="nf">_internal_forcing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calcflux</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">calcbal</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculate the system&#39;s internal forcing</span>

<span class="sd">        This is a core method for the numerical finite elements scheme. The</span>
<span class="sd">        default behavior is to calculate the system&#39;s internal forcing and</span>
<span class="sd">        accumulate the values to :math:`F_{forcing}` which is saved in the</span>
<span class="sd">        model as :py:attr:`~forcing`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        calcflux : `bool`, default is False</span>
<span class="sd">            If ``True``, fluxes through the nodes are calculated and</span>
<span class="sd">            saved in :py:attr:`~fluxes`.</span>
<span class="sd">        calcbal : `bool`, default = False</span>
<span class="sd">            If ``True``, internal forcing is saved in</span>
<span class="sd">            :py:attr:`~internal_forcing` instead of :py:attr:`~forcing`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This mathematical description of the internal forcing</span>
<span class="sd">        calculation describes how the forcing at the nodes is calculated.</span>
<span class="sd">        The direction of flow is defined to be positive to the right.</span>
<span class="sd">        The equation below describes how the forcing at a specific node can</span>
<span class="sd">        be calculated, taking the Gaussian quadrature procedure into account.</span>

<span class="sd">        .. math::</span>
<span class="sd">            F_{i} = \\sum_{\\lambda=1}^{\\Lambda} Q(X_{i,\\lambda}, s_{i,\\lambda}+\\delta x, grad_{i}) * w_{\\lambda}</span>

<span class="sd">        Argument :math:`X_{i, \\lambda}` represents the absolute position</span>
<span class="sd">        of the Gaussian quadrature point as saved in :py:attr:`~xintegration`.</span>
<span class="sd">        The state argument :math:`s_{i,\\lambda}` at this specific Gaussian</span>
<span class="sd">        quadrature point is calculated as follows:</span>

<span class="sd">        .. math::</span>
<span class="sd">            s_{i,\\lambda} = s_{i} * (1-p_{\\lambda}) + s_{i+1} * p_{\\lambda}</span>

<span class="sd">        The third argument, :math:`grad_{i}`, is the gradient of the state</span>
<span class="sd">        between the nodes of the current segment and is calculated as</span>
<span class="sd">        shown below:</span>

<span class="sd">        .. math::</span>
<span class="sd">            grad_{i} = \\frac{s_{i+1} - s{i}}{L_{i}}</span>

<span class="sd">        All internal fluxes are collected in :math:`F_{internal}`.</span>

<span class="sd">        .. math::</span>
<span class="sd">            F_{internal} = \\begin{bmatrix}</span>
<span class="sd">                                -F_{i}              \\\\</span>
<span class="sd">                                F_{i} - F_{i+1}    \\\\</span>
<span class="sd">                                F_{i+1} - F_{i+2}  \\\\</span>
<span class="sd">                                \\vdots            \\\\</span>
<span class="sd">                                F_{N-1} - F_{N}    \\\\</span>
<span class="sd">                                F_{N}</span>
<span class="sd">                           \\end{bmatrix}</span>

<span class="sd">        .. note::</span>
<span class="sd">            If both of the arguments are truthy, the argument which occurs in</span>
<span class="sd">            the method signature first has highest precedence. The internal</span>
<span class="sd">            forcing is only assigned to the :py:attr:`~forcing` attribute</span>
<span class="sd">            when called with default arguments.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from waterflow.flow1d.flowFE1d import Flow1DFE</span>
<span class="sd">        &gt;&gt;&gt; from waterflow.utility import conductivityfunctions as condf</span>
<span class="sd">        &gt;&gt;&gt; from waterflow.utility.fluxfunctions import richards_equation</span>
<span class="sd">        &gt;&gt;&gt; from waterflow.utility.helper import initializer</span>

<span class="sd">        Select soil 13, &#39;loam&#39;, from De Staringreeks :cite:`Wosten2001`</span>
<span class="sd">        and prepare the conductivity function with the soil parameters.</span>

<span class="sd">        &gt;&gt;&gt; s, *_ = condf.soilselector([13])[0]</span>
<span class="sd">        &gt;&gt;&gt; kfun = initializer(condf.VG_conductivity, ksat=s.ksat, a=s.alpha, n=s.n)</span>

<span class="sd">        Add states for a stationary no flow situation and check the</span>
<span class="sd">        :py:attr:`~forcing` attribute for the internal forcing values.</span>

<span class="sd">        &gt;&gt;&gt; FE = Flow1DFE(&quot;Internal forcing example&quot;)</span>
<span class="sd">        &gt;&gt;&gt; FE.set_systemfluxfunction(richards_equation, kfun=kfun)</span>
<span class="sd">        &gt;&gt;&gt; FE.set_field1d(nodes=(-10, 0, 11))</span>
<span class="sd">        &gt;&gt;&gt; FE.set_initial_states([-i for i in range(11)])</span>
<span class="sd">        &gt;&gt;&gt; FE.set_gaussian_quadrature(3)</span>
<span class="sd">        &gt;&gt;&gt; FE._internal_forcing()</span>
<span class="sd">        &gt;&gt;&gt; FE.forcing</span>
<span class="sd">        array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])</span>
<span class="sd">        &gt;&gt;&gt; FE._internal_forcing(calcflux=True)</span>
<span class="sd">        &gt;&gt;&gt; FE.fluxes</span>
<span class="sd">        array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])</span>

<span class="sd">        Both arrays should consist of zeros because of the applied</span>
<span class="sd">        equilibrium situation with no flow over the boundaries.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># internal fluxes from previous iteration</span>
        <span class="n">pos</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussquad</span>
        <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">))]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seg_lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">)):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xintegration</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[</span><span class="o">-</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">grad</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="n">L</span>
                <span class="n">flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">systemfluxfunc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">grad</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">calcflux</span><span class="p">:</span>
                    <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">flux</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="o">-</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">flux</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">calcflux</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># if balance calculation, don&#39;t assign to forcing again</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">calcbal</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">internal_forcing</span><span class="p">[</span><span class="s2">&quot;internal_forcing&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">)]</span></div>

<div class="viewcode-block" id="Flow1DFE._statedep_forcing"><a class="viewcode-back" href="../../../waterflow.flow1d.html#waterflow.flow1d.flowFE1d.Flow1DFE._statedep_forcing">[docs]</a>    <span class="k">def</span> <span class="nf">_statedep_forcing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculation of state dependent forcing values</span>

<span class="sd">        Values for the state dependent forcing functions saved in</span>
<span class="sd">        :py:attr:`~Sspatflux` and :py:attr:`~Spointflux` are calculated.</span>
<span class="sd">        The local forcing matrices :math:`F_{local}` are populated and the</span>
<span class="sd">        total of both is accumulated to the global forcing matrix</span>
<span class="sd">        :math:`F_{forcing}`. Forcing values at the position of a Dirichlet</span>
<span class="sd">        boundary condition are set to zero. This method is called internally</span>
<span class="sd">        by :py:meth:`~dt_solve` to prepare for the next iteration.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Calculations of the individual spatial fluxes :math:`j` are saved in</span>
<span class="sd">        the local forcing matrix :math:`F_{local}`. The following two</span>
<span class="sd">        components need to be calculated over the complete domain of the</span>
<span class="sd">        system for the specific spatialflux. The Gaussian quadrature degree</span>
<span class="sd">        :math:`\\Lambda` is accounted for.</span>

<span class="sd">        .. math::</span>
<span class="sd">            F_{l_{i}} = \\sum_{\\lambda=1}^{\\Lambda} S(X_{i, \\lambda}, s_{i,\\lambda})_{j} * (1-p_{\\lambda}) * w_{\\lambda} * L_{i}</span>

<span class="sd">        .. math::</span>
<span class="sd">            F_{r_{i}} = \\sum_{\\lambda=1}^{\\Lambda} S(X_{i, \\lambda}, s_{i,\\lambda})_{j} * p_{\\lambda} * w_{\\lambda} * L_{i}</span>

<span class="sd">        where the state argument :math:`s_{i,j}` is calculated by linear</span>
<span class="sd">        interpolation as shown below:</span>

<span class="sd">        .. math::</span>
<span class="sd">            s_{i,\\lambda} = s_{i} + (X_{i,\\lambda} - x_{i}) * \\frac{s_{i+1} - s_{i}}{L_{i}}</span>

<span class="sd">        Calculations of the individual point fluxes :math:`k` are also saved</span>
<span class="sd">        in its local forcing matrix :math:`F_{local}`. The following two</span>
<span class="sd">        components need to be calculated at the position of the specific</span>
<span class="sd">        pointflux:</span>

<span class="sd">        .. math::</span>
<span class="sd">            F_{l_{i}} = P(s_{i,k})_{k} * lfac_{k}</span>

<span class="sd">        .. math::</span>
<span class="sd">            F_{r_{i}} = P(s_{i,k})_{k} * rfac_{k}</span>

<span class="sd">        where the state argument :math:`s_{i,k}` is calculated by linear</span>
<span class="sd">        interpolation as shown below:</span>

<span class="sd">        .. math::</span>
<span class="sd">            s_{i,k} = s_{i} + rfac_{k} * (s_{i+1} - s_{i})</span>

<span class="sd">        The local forcing matrix is populated as follows, this scheme</span>
<span class="sd">        is used for both the pointflux and the spatialflux calculation.</span>

<span class="sd">        .. math::</span>
<span class="sd">            F_{local} = \\begin{bmatrix}</span>
<span class="sd">                          F_{l_{i}}                  \\\\</span>
<span class="sd">                          F_{r_{i}} + F_{l_{i+1}}    \\\\</span>
<span class="sd">                          F_{r_{i+1}} + F_{l_{i+2}}  \\\\</span>
<span class="sd">                          \\vdots                    \\\\</span>
<span class="sd">                          F_{r_{N-1}} + F_{l_{N}}  \\\\</span>
<span class="sd">                          F_{r_{N}}</span>
<span class="sd">                        \\end{bmatrix}</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from waterflow.flow1d.flowFE1d import Flow1DFE</span>
<span class="sd">        &gt;&gt;&gt; FE = Flow1DFE(&quot;state dependent fluxes&quot;)</span>
<span class="sd">        &gt;&gt;&gt; FE.set_field1d((-10, 0, 11))</span>
<span class="sd">        &gt;&gt;&gt; # Set initial states other than all zeros</span>
<span class="sd">        &gt;&gt;&gt; FE.set_initial_states([-i for i in range(11)])</span>

<span class="sd">        &gt;&gt;&gt; # Define a state dependent pointflux function</span>
<span class="sd">        &gt;&gt;&gt; def Spflux(s):</span>
<span class="sd">        ...     return abs(np.sin(s)) * -0.1</span>
<span class="sd">        &gt;&gt;&gt; FE.add_pointflux(Spflux, -3.1)</span>

<span class="sd">        &gt;&gt;&gt; # Define a state dependent spatialflux function</span>
<span class="sd">        &gt;&gt;&gt; def linear_s_extraction(x, s):</span>
<span class="sd">        ...     return -0.001 * abs(x) - 0.001 * s</span>
<span class="sd">        &gt;&gt;&gt; FE.add_spatialflux(linear_s_extraction)</span>

<span class="sd">        &gt;&gt;&gt; # Calculcate state dependent forcing (for next iteration)</span>
<span class="sd">        &gt;&gt;&gt; FE._statedep_forcing()</span>
<span class="sd">        &gt;&gt;&gt; # Local forcing matrix of Spflux</span>
<span class="sd">        &gt;&gt;&gt; FE.Spointflux[&#39;Spflux&#39;][1]</span>
<span class="sd">        array([ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,</span>
<span class="sd">                0.        , -0.0057844 , -0.05205958,  0.        ,  0.        ,</span>
<span class="sd">                0.        ])</span>
<span class="sd">        &gt;&gt;&gt; # Local forcing matrix of &#39;linear_s_extraction&#39;</span>
<span class="sd">        &gt;&gt;&gt; FE.Sspatflux[&#39;linear_s_extraction&#39;][1]</span>
<span class="sd">        array([-0.0045, -0.008 , -0.006 , -0.004 , -0.002 ,  0.    ,  0.002 ,</span>
<span class="sd">                0.004 ,  0.006 ,  0.008 ,  0.0045])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># point state dependent forcing</span>
        <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">))]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Spointflux</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="p">(</span><span class="n">Sfunc</span><span class="p">,</span> <span class="p">(</span><span class="n">idx_l</span><span class="p">,</span> <span class="n">idx_r</span><span class="p">,</span> <span class="n">lfac</span><span class="p">,</span> <span class="n">rfac</span><span class="p">)),</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Spointflux</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="c1"># calculate state at position by linear interpolation</span>
            <span class="n">dstates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">idx_r</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">idx_l</span><span class="p">]</span>
            <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">idx_l</span><span class="p">]</span> <span class="o">+</span> <span class="n">rfac</span> <span class="o">*</span> <span class="n">dstates</span>
            <span class="c1"># calculate function value and distribute fluxes accordingly</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">Sfunc</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="n">f</span><span class="p">[</span><span class="n">idx_l</span><span class="p">]</span> <span class="o">+=</span> <span class="n">value</span> <span class="o">*</span> <span class="n">lfac</span>
            <span class="n">f</span><span class="p">[</span><span class="n">idx_r</span><span class="p">]</span> <span class="o">+=</span> <span class="n">value</span> <span class="o">*</span> <span class="n">rfac</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Spointflux</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="c1"># spatial state dependent forcing</span>
        <span class="n">pos</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussquad</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sspatflux</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">))]</span>
            <span class="n">Sfunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sspatflux</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seg_lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">)):</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xintegration</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
                    <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="c1"># linearly interpolate the state value</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">ds</span> <span class="o">/</span> <span class="n">L</span><span class="p">)</span>
                    <span class="c1"># assign to nearby nodes according to scheme</span>
                    <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Sfunc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="o">-</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[</span><span class="o">-</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">L</span>
                    <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Sfunc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">L</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">Sspatflux</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="c1"># aggregate state dependent forcing</span>
        <span class="k">for</span> <span class="n">flux</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Spointflux</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sspatflux</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">flux</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span> <span class="o">+=</span> <span class="n">flux</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># add boundaries of type dirichlet</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">BCs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">val</span><span class="p">,</span> <span class="n">type_</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BCs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">type_</span> <span class="o">==</span> <span class="s2">&quot;Dirichlet&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># reshape for matrix solver</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span></div>

<div class="viewcode-block" id="Flow1DFE._check_boundaries"><a class="viewcode-back" href="../../../waterflow.flow1d.html#waterflow.flow1d.flowFE1d.Flow1DFE._check_boundaries">[docs]</a>    <span class="k">def</span> <span class="nf">_check_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Check for proper boundary conditions</span>

<span class="sd">        The system is checked for singularity. When a boundary condition</span>
<span class="sd">        is not explicitly set, a natural boundary condition (no flow) is</span>
<span class="sd">        set as default.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        numpy.linalg.LinAlgError</span>
<span class="sd">            This error is raised if the system has infinitely many solutions</span>
<span class="sd">            as a consequence of two Neumann boundary conditions or when none</span>
<span class="sd">            are entered.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from waterflow.flow1d.flowFE1d import Flow1DFE</span>
<span class="sd">        &gt;&gt;&gt; FE = Flow1DFE(&quot;Check boundaries&quot;)</span>
<span class="sd">        &gt;&gt;&gt; FE.set_field1d((-10, 0, 11))</span>
<span class="sd">        &gt;&gt;&gt; FE.add_neumann_BC(-0.3, &quot;west&quot;)</span>
<span class="sd">        &gt;&gt;&gt; FE.BCs</span>
<span class="sd">        {&#39;west&#39;: (-0.3, &#39;Neumann&#39;, 0)}</span>
<span class="sd">        &gt;&gt;&gt; FE._check_boundaries()</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">         ...</span>
<span class="sd">        numpy.linalg.LinAlgError: Singular matrix</span>
<span class="sd">        &gt;&gt;&gt; FE.add_dirichlet_BC(-100, &quot;west&quot;)</span>
<span class="sd">        &gt;&gt;&gt; FE.BCs</span>
<span class="sd">        {&#39;west&#39;: (-100, &#39;Dirichlet&#39;, 0)}</span>
<span class="sd">        &gt;&gt;&gt; FE._check_boundaries()</span>
<span class="sd">        &gt;&gt;&gt; FE.BCs</span>
<span class="sd">        {&#39;west&#39;: (-100, &#39;Dirichlet&#39;, 0), &#39;east&#39;: (0, &#39;Neumann&#39;, -1)}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># no boundary conditions entered</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">BCs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">(</span><span class="s2">&quot;Singular matrix&quot;</span><span class="p">)</span>

        <span class="c1"># if one boundary is not entered a zero Neumann boundary is set</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">val</span><span class="p">,</span> <span class="n">type_</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BCs</span><span class="p">[</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">type_</span> <span class="o">==</span> <span class="s2">&quot;Dirichlet&quot;</span> <span class="ow">and</span> <span class="n">pos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_neumann_BC</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s2">&quot;east&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">type_</span> <span class="o">==</span> <span class="s2">&quot;Dirichlet&quot;</span> <span class="ow">and</span> <span class="n">pos</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_neumann_BC</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s2">&quot;west&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">(</span><span class="s2">&quot;Singular matrix&quot;</span><span class="p">)</span>

        <span class="c1"># both boundaries cannot be of type Neumann</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">val0</span><span class="p">,</span> <span class="n">type_0</span><span class="p">,</span> <span class="n">pos0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BCs</span><span class="p">[</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">val1</span><span class="p">,</span> <span class="n">type_1</span><span class="p">,</span> <span class="n">pos1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BCs</span><span class="p">[</span><span class="n">keys</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">type_0</span> <span class="o">==</span> <span class="n">type_1</span> <span class="ow">and</span> <span class="n">type_0</span> <span class="o">==</span> <span class="s2">&quot;Neumann&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">(</span><span class="s2">&quot;Singular matrix&quot;</span><span class="p">)</span>

        <span class="c1"># constrain the states to the applied boundary conditions</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="n">val</span><span class="p">,</span> <span class="n">type_</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BCs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">type_</span> <span class="o">==</span> <span class="s2">&quot;Dirichlet&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span></div>

<div class="viewcode-block" id="Flow1DFE._calc_theta_k"><a class="viewcode-back" href="../../../waterflow.flow1d.html#waterflow.flow1d.flowFE1d.Flow1DFE._calc_theta_k">[docs]</a>    <span class="k">def</span> <span class="nf">_calc_theta_k</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Conductivities and moisture contents</span>

<span class="sd">        Calculation of conductivities and moisture contents in the system.</span>
<span class="sd">        The results are saved in :py:attr:`~conductivities` and</span>
<span class="sd">        :py:attr:`~moisture` and will be included in :py:attr:`~df_states`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The conductivity function is part of the :py:attr:`~systemfluxfunc`.</span>
<span class="sd">        The moisture content function should be assigned to the model</span>
<span class="sd">        explicitly. See the example below.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from waterflow.flow1d.flowFE1d import Flow1DFE</span>
<span class="sd">        &gt;&gt;&gt; from waterflow.utility import conductivityfunctions as condf</span>
<span class="sd">        &gt;&gt;&gt; from waterflow.utility import fluxfunctions as fluxf</span>
<span class="sd">        &gt;&gt;&gt; from waterflow.utility.helper import initializer</span>

<span class="sd">        Select soil 13, &#39;loam&#39;, from De Staringreeks :cite:`Wosten2001`</span>
<span class="sd">        and prepare the conductivity function and theta-h relation with the</span>
<span class="sd">        soil parameters. These functions are the arguments to the fluxfunction</span>
<span class="sd">        and the storage change function repectively.</span>

<span class="sd">        &gt;&gt;&gt; s, *_ = condf.soilselector([13])[0]</span>
<span class="sd">        &gt;&gt;&gt; theta_h = initializer(condf.VG_pressureh, theta_r=s.t_res,</span>
<span class="sd">        ...                       theta_s=s.t_sat, a=s.alpha, n=s.n)</span>
<span class="sd">        &gt;&gt;&gt; kfun = initializer(condf.VG_conductivity, ksat=s.ksat, a=s.alpha, n=s.n)</span>

<span class="sd">        &gt;&gt;&gt; FE = Flow1DFE(&quot;Calculate water balance&quot;)</span>
<span class="sd">        &gt;&gt;&gt; FE.set_field1d(nodes=(-10, 0, 11))</span>
<span class="sd">        &gt;&gt;&gt; # The conductivity function is added as argument to the systemfluxfunction</span>
<span class="sd">        &gt;&gt;&gt; FE.set_systemfluxfunction(fluxf.richards_equation, kfun=kfun)</span>
<span class="sd">        &gt;&gt;&gt; FE._calc_theta_k()</span>
<span class="sd">        &gt;&gt;&gt; FE.conductivities</span>
<span class="sd">        array([12.98, 12.98, 12.98, 12.98, 12.98, 12.98, 12.98, 12.98, 12.98,</span>
<span class="sd">               12.98, 12.98])</span>
<span class="sd">        &gt;&gt;&gt; # Omitting a function will skip the calculation (e.g. in case of saturated flow)</span>
<span class="sd">        &gt;&gt;&gt; FE.moisture</span>
<span class="sd">        []</span>
<span class="sd">        &gt;&gt;&gt; # Create an equilibrium situation</span>
<span class="sd">        &gt;&gt;&gt; FE.set_initial_states([-i for i in range(10)])</span>
<span class="sd">        &gt;&gt;&gt; # Now add the moisture content function explicitly</span>
<span class="sd">        &gt;&gt;&gt; FE.tfun = theta_h</span>
<span class="sd">        &gt;&gt;&gt; # Calculate again</span>
<span class="sd">        &gt;&gt;&gt; FE._calc_theta_k()</span>
<span class="sd">        &gt;&gt;&gt; FE.conductivities</span>
<span class="sd">        array([12.98      , 10.01657823,  9.05018386,  8.36428965,  7.8189874 ,</span>
<span class="sd">                7.36164639,  6.96580186,  6.61596642,  6.30216943,  6.01755319])</span>
<span class="sd">        &gt;&gt;&gt; FE.moisture</span>
<span class="sd">        array([0.42      , 0.41987202, 0.41965291, 0.41937832, 0.41906052,</span>
<span class="sd">               0.41870661, 0.41832137, 0.41790836, 0.41747038, 0.4170097 ])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;kfun&#39;</span><span class="p">):</span>
            <span class="n">k</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">kfun</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conductivities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;tfun&#39;</span><span class="p">):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tfun</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">moisture</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">t</span><span class="p">)</span></div>

<div class="viewcode-block" id="Flow1DFE._update_storage_change"><a class="viewcode-back" href="../../../waterflow.flow1d.html#waterflow.flow1d.flowFE1d.Flow1DFE._update_storage_change">[docs]</a>    <span class="k">def</span> <span class="nf">_update_storage_change</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prevstate</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Update states function and time step size of storage change function</span>

<span class="sd">        The storage change function is implemented as a spatial state</span>
<span class="sd">        dependent flux function. Therefore, it needs to match its mandatory</span>
<span class="sd">        function signature as described in :py:meth:`~add_spatialflux`. This</span>
<span class="sd">        method updates the ``prevstate`` and ``dt`` arguments by changing these</span>
<span class="sd">        default arguments of the storage change function so that the calling</span>
<span class="sd">        signature remains the same.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        prevstate : `func`</span>
<span class="sd">            Function that calculates the system&#39;s states :math:`s` for a given</span>
<span class="sd">            position :math:`x`.</span>
<span class="sd">        dt : `float` or `int`</span>
<span class="sd">            Time step over which the storage change will be calculated.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The storage change function, if present, is stored in</span>
<span class="sd">        :py:attr:`~Sspatflux`. The calling signature may look as follows:</span>

<span class="sd">        ..  math::</span>
<span class="sd">            storage\\textunderscore change(x, s, prevstate, dt, fun=lambda\\text{ }x: 1, S=1)</span>

<span class="sd">        The :math:`prevstate` and :math:`dt` argument need to be updated for</span>
<span class="sd">        every new time step and are set as default values so the storage</span>
<span class="sd">        change function can be called with the signature demanded by</span>
<span class="sd">        :py:meth:`~add_spatialflux`. See</span>
<span class="sd">        :py:func:`~waterflow.utility.fluxfunctions.storage_change` for the</span>
<span class="sd">        complete definition of the storage change function.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">storagechange</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sspatflux</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;storage_change&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">storagechange</span><span class="p">:</span>
            <span class="n">storagechange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">storagechange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                       <span class="n">prevstate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">states_to_function</span><span class="p">(),</span>
                                       <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span></div>

<div class="viewcode-block" id="Flow1DFE._solve_initial_object"><a class="viewcode-back" href="../../../waterflow.flow1d.html#waterflow.flow1d.flowFE1d.Flow1DFE._solve_initial_object">[docs]</a>    <span class="k">def</span> <span class="nf">_solve_initial_object</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculation on first model input</span>

<span class="sd">        Calculations on the input data for the first object, used as</span>
<span class="sd">        first entry in any of the model&#39;s dataframes.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If :py:attr:`~isinitial` equals ``True`` the boundaries of the model</span>
<span class="sd">        are checked, the internal forcing is calculated and the storage change</span>
<span class="sd">        function is updated, if present.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The values calculated by this method and included in the model&#39;s</span>
<span class="sd">            dataframes as first entries not need to make any sense because the</span>
<span class="sd">            user can set any unrealistic combination of initial input.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isinitial</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_boundaries</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_internal_forcing</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_storage_change</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states_to_function</span><span class="p">(),</span> <span class="n">dt</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="Flow1DFE._FE_precalc"><a class="viewcode-back" href="../../../waterflow.flow1d.html#waterflow.flow1d.flowFE1d.Flow1DFE._FE_precalc">[docs]</a>    <span class="k">def</span> <span class="nf">_FE_precalc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Discretization lengths</span>

<span class="sd">        Calculate the values for :py:attr:`~seg_lengths` and</span>
<span class="sd">        :py:attr:`~lengths`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The lengths of the segments between the nodes are calculated as</span>
<span class="sd">        follows. The number of segments is always one less than the number of</span>
<span class="sd">        nodes in the system.</span>

<span class="sd">        .. math::</span>
<span class="sd">            L_{i} = x_{i+1} - x_{i} \\text{ for } i=1,2,\\dotsc,N-1</span>

<span class="sd">        To assign a length to every node in the system, a different approach</span>
<span class="sd">        has been used. Except for the boundary cases, the differences of the</span>
<span class="sd">        midpoints between the nodes has been taken as a segment length. See the</span>
<span class="sd">        exact definition:</span>

<span class="sd">        .. math::</span>
<span class="sd">            nL_{i} =</span>
<span class="sd">                \\begin{cases}</span>
<span class="sd">                \\frac{x_{i}+x_{i+1}}{2} - x_{i}                  &amp; \\text{ for } i=1 \\\\</span>
<span class="sd">                \\frac{x_{i+1}-x_{i-1}}{2}                        &amp; \\text{ for } i=2,3,\\dotsc,N-1 \\\\</span>
<span class="sd">                x_{i}-\\frac{x_{i-1}+x_{i}}{2}                    &amp; \\text{ for } i=N</span>
<span class="sd">                \\end{cases}</span>

<span class="sd">        Multiplication of :math:`nL_{i}` with scalar or sequence like</span>
<span class="sd">        spatial fluxes result in a forcing array that has the shape</span>
<span class="sd">        :math:`[1 \\times N]` which is convenient for direct addition to the</span>
<span class="sd">        global :py:attr:`~forcing` matrix.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from waterflow.flow1d.flowFE1d import Flow1DFE</span>
<span class="sd">        &gt;&gt;&gt; FE = Flow1DFE(&quot;Flow equations&quot;)</span>
<span class="sd">        &gt;&gt;&gt; # FE_precalc() is called implicitly by set_field1d()</span>
<span class="sd">        &gt;&gt;&gt; FE.set_field1d((-10, 0, 11))</span>
<span class="sd">        &gt;&gt;&gt; FE.seg_lengths</span>
<span class="sd">        array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])</span>
<span class="sd">        &gt;&gt;&gt; FE.lengths</span>
<span class="sd">        array([0.5, 1. , 1. , 1. , 1. , 1. , 1. , 1. , 1. , 1. , 0.5])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">slen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">nlen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">))</span>

        <span class="c1"># calculate both arrays in one loop &amp; catch boundary cases</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">nlen</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">nlen</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nlen</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">slen</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># assign to class attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seg_lengths</span> <span class="o">=</span> <span class="n">slen</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lengths</span> <span class="o">=</span> <span class="n">nlen</span></div>

<div class="viewcode-block" id="Flow1DFE._CMAT"><a class="viewcode-back" href="../../../waterflow.flow1d.html#waterflow.flow1d.flowFE1d.Flow1DFE._CMAT">[docs]</a>    <span class="k">def</span> <span class="nf">_CMAT</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">states</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Build the jacobian matrix</span>

<span class="sd">        Build the complete jacobian matrix according to the finite elements</span>
<span class="sd">        scheme for the selected degree :math:`\\Lambda`. The jacobian matrix</span>
<span class="sd">        :math:`A` is assigned to :py:attr:`~coefmatr`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes : `numpy.ndarray`</span>
<span class="sd">            Array that contains the nodal positions.</span>
<span class="sd">        states : `numpy.ndarray`</span>
<span class="sd">            Array that contains the states at the nodal positions.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The jacobian matrix :math:`A` is build from three individual parts.</span>

<span class="sd">        .. math::</span>
<span class="sd">            A = A_{sys} + A_{spat} + A_{point}</span>

<span class="sd">        * :math:`A_{sys}`, derivatives of the :py:attr:`~systemfluxfunc`, :math:`Q`.</span>
<span class="sd">        * :math:`A_{spat}`, derivatives of functions in :py:attr:`~Sspatflux`, :math:`S`.</span>
<span class="sd">        * :math:`A_{point}`, derivatives of functions in :py:attr:`~Spointflux`, :math:`P`.</span>

<span class="sd">        **System&#39;s flow equation jacobian**</span>

<span class="sd">        The derivatives of the systemflux function, :math:`Q`, are collected</span>
<span class="sd">        in :math:`A_{sys}`. The equation below describes how the</span>
<span class="sd">        derivatives are calculated in which the Gaussian quadrature scheme</span>
<span class="sd">        is accounted for.</span>

<span class="sd">        .. math::</span>
<span class="sd">            \\frac{\\delta Q}{\\delta x}_{i} = \\sum_{\\lambda}^{\\Lambda} \\frac{Q(X_{i,\\lambda}, s_{i,\\lambda}+\\delta x, grad_{i}) - Q(X_{i,\\lambda}, s_{i,\\lambda}, grad_{i})}{\\delta x} * w_{\\lambda}</span>

<span class="sd">        Argument :math:`X_{i, \\lambda}` represents the absolute position</span>
<span class="sd">        of the Gaussian quadrature point as saved in :py:attr:`~xintegration`.</span>
<span class="sd">        The state argument :math:`s_{i,\\lambda}` at this specific Gaussian</span>
<span class="sd">        quadrature point is calculated as follows:</span>

<span class="sd">        .. math::</span>
<span class="sd">            s_{i,\\lambda} = s_{i} * (1-p_{\\lambda}) + s_{i+1} * p_{\\lambda}</span>

<span class="sd">        The third argument, :math:`grad_{i}`, is the gradient of the state</span>
<span class="sd">        between the nodes of the current segment and is calculated as</span>
<span class="sd">        shown below:</span>

<span class="sd">        .. math::</span>
<span class="sd">            grad_{i} = \\frac{s_{i+1} - s_{i}}{L_{i}}</span>

<span class="sd">        :math:`A_{sys}` presents the structure of the sparse jacobian matrix</span>
<span class="sd">        in which the derivatives of the systemflux function :math:`Q` are</span>
<span class="sd">        saved.</span>

<span class="sd">        .. math::</span>
<span class="sd">            A_{sys} = \\begin{bmatrix}</span>
<span class="sd">                            -\\frac{\\delta Q}{\\delta x}_{i} &amp; -\\frac{\\delta Q}{\\delta x}_{i} &amp;  &amp;  &amp;  &amp; \\\\</span>
<span class="sd">                            \\frac{\\delta Q}{\\delta x}_{i} &amp; \\frac{\\delta Q}{\\delta x}_{i} -\\frac{\\delta Q}{\\delta x}_{i+1} &amp; -\\frac{\\delta Q}{\\delta x}_{i+1} &amp;  &amp; &amp; \\\\</span>
<span class="sd">                             &amp; \\frac{\\delta Q}{\\delta x}_{i+1} &amp; \\frac{\\delta Q}{\\delta x}_{i+1} -\\frac{\\delta Q}{\\delta x}_{i+2} &amp; \\ddots &amp; &amp; \\\\</span>
<span class="sd">                             &amp;  &amp; \\ddots &amp; \\ddots &amp; &amp; \\ddots &amp; \\\\</span>
<span class="sd">                             &amp;  &amp;  &amp; \\ddots &amp;  &amp; \\frac{\\delta Q}{\\delta x}_{N-1} -\\frac{\\delta Q}{\\delta x}_{N} &amp; -\\frac{\\delta Q}{\\delta x}_{N} \\\\</span>
<span class="sd">                             &amp;  &amp;  &amp;  &amp;  &amp; \\frac{\\delta Q}{\\delta x}_{N} &amp; \\frac{\\delta Q}{\\delta x}_{N}</span>
<span class="sd">                    \\end{bmatrix}</span>

<span class="sd">        **Spatial state dependent jacobian**</span>

<span class="sd">        The derivatives of the state dependent spatial fluxes :math:`S`, if</span>
<span class="sd">        present, are collected in :math:`A_{spat}`. The calculation of these</span>
<span class="sd">        derivatives is described by the equations below. The values are summed</span>
<span class="sd">        at every segment in the model domain, taking into account the selected</span>
<span class="sd">        Gaussian quadrature scheme.</span>

<span class="sd">        .. math::</span>
<span class="sd">            \\sum \\frac{\\delta S_{l}}{\\delta x}_{i} = \\sum_{\\lambda=1}^{\\Lambda} \\sum_{j=1}^{n} \\frac{S(X_{i,\\lambda}, s_{i,\\lambda} + \\delta x)_{j} - S(X_{i,\\lambda}, s_{i,\\lambda})_{j}}{\\delta x} * L_{i} * (1-p_{\\lambda}) * w_{\\lambda}</span>

<span class="sd">        .. math::</span>
<span class="sd">            \\sum \\frac{\\delta S_{r}}{\\delta x}_{i} = \\sum_{\\lambda=1}^{\\Lambda} \\sum_{j=1}^{n} \\frac{S(X_{i,\\lambda}, s_{i,\\lambda} + \\delta x)_{j} - S(X_{i,\\lambda}, s_{i,\\lambda})_{j}}{\\delta x} * L_{i} * p_{\\lambda} * w_{\\lambda}</span>

<span class="sd">        Argument :math:`X_{i, \\lambda}` represents the absolute position</span>
<span class="sd">        of the Gaussian quadrature point as saved in :py:attr:`~xintegration`.</span>
<span class="sd">        The state argument :math:`s_{i,\\lambda}` at this specific Gaussian</span>
<span class="sd">        quadrature point is calculated as follows:</span>

<span class="sd">        .. math::</span>
<span class="sd">            s_{i,\\lambda} = s_{i} * (1-p_{\\lambda}) + s_{i+1} * p_{\\lambda}</span>

<span class="sd">        The structure of the sparse jacobian matrix, :math:`A_{spat}`, of the</span>
<span class="sd">        sum of all state dependent spatialflux function derivatives is shown</span>
<span class="sd">        below:</span>

<span class="sd">        .. math::</span>
<span class="sd">            A_{spat} = \\begin{bmatrix}</span>
<span class="sd">                            \\Sigma \\frac{\\delta S_{l}}{\\delta x}_{i} &amp; \\Sigma \\frac{\\delta S_{r}}{\\delta x}_{i} &amp;  &amp;  &amp;  &amp; \\\\</span>
<span class="sd">                            \\Sigma \\frac{\\delta S_{l}}{\\delta x}_{i} &amp; \\Sigma \\frac{\\delta S_{r}}{\\delta x}_{i} + \\Sigma \\frac{\\delta S_{l}}{\\delta x}_{i+1} &amp; \\Sigma \\frac{\\delta S_{r}}{\\delta x}_{i+1} &amp;  &amp; &amp; \\\\</span>
<span class="sd">                              &amp; \\Sigma \\frac{\\delta S_{l}}{\\delta x}_{i+1} &amp; \\Sigma \\frac{\\delta S_{r}}{\\delta x}_{i+1} + \\Sigma \\frac{\\delta S_{l}}{\\delta x}_{i+2} &amp; \\ddots &amp; &amp; \\\\</span>
<span class="sd">                              &amp;  &amp; \\ddots &amp; \\ddots &amp; &amp; \\ddots &amp; \\\\</span>
<span class="sd">                              &amp;  &amp;  &amp; \\ddots &amp;  &amp; \\Sigma \\frac{\\delta S_{r}}{\\delta x}_{N-1} + \\Sigma \\frac{\\delta S_{l}}{\\delta x}_{N} &amp; \\Sigma \\frac{\\delta S_{r}}{\\delta x}_{N} \\\\</span>
<span class="sd">                              &amp;  &amp;  &amp;  &amp;  &amp; \\Sigma \\frac{\\delta S_{l}}{\\delta x}_{N} &amp; \\Sigma \\frac{\\delta S_{r}}{\\delta x}_{N}</span>
<span class="sd">                       \\end{bmatrix}</span>

<span class="sd">        **Point state dependent jacobian**</span>

<span class="sd">        The derivatives of the state dependent point fluxes, :math:`P`, if</span>
<span class="sd">        present, are collected in :math:`A_{point}`. The derivates are</span>
<span class="sd">        calculated for the specific functions, distributed to the two nearest</span>
<span class="sd">        nodes and summed to a total at this specific position. This is</span>
<span class="sd">        described by the equations below:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \\sum \\frac{\\delta P_{l}}{\\delta x}_{i} = \\sum_{k=1}^{m} \\frac{P(s_{i,k} + \\delta x)_{k} + P(s_{i,k})_{k}}{\\delta x} * rfac_{k}</span>

<span class="sd">        .. math::</span>
<span class="sd">            \\sum \\frac{\\delta P_{r}}{\\delta x}_{i} = \\sum_{k=1}^{m} \\frac{P(s_{i,k} + \\delta x)_{k} + P(s_{i,k})_{k}}{\\delta x} * lfac_{k}</span>

<span class="sd">        The state argument, :math:`s_{i,k}`, is calculated by linear</span>
<span class="sd">        interpolation between the nearest nodes.</span>

<span class="sd">        .. math::</span>
<span class="sd">            s_{i,k} = s_{i} + rfac_{k} * (s_{i+1} - s_{i})</span>

<span class="sd">        The structure of the jacobian matrix, :math:`A_{point}`, of the sum of</span>
<span class="sd">        all state dependent pointflux function derivatives is shown below:</span>

<span class="sd">        .. math::</span>
<span class="sd">            A_{point} = \\begin{bmatrix}</span>
<span class="sd">                            \\Sigma \\frac{\\delta P_{l}}{\\delta x}_{i} &amp;  &amp;  &amp;  &amp;  &amp; \\\\</span>
<span class="sd">                            &amp; \\Sigma \\frac{\\delta P_{r}}{\\delta x}_{i} + \\Sigma \\frac{\\delta P_{l}}{\\delta x}_{i+1} &amp;  &amp;  &amp;  &amp;  \\\\</span>
<span class="sd">                            &amp;  &amp; \\Sigma \\frac{\\delta P_{r}}{\\delta x}_{i+1} + \\Sigma \\frac{\\delta P_{l}}{\\delta x}_{i+2} &amp;  &amp;  &amp;  \\\\</span>
<span class="sd">                            &amp;  &amp;  &amp; \\ddots &amp;  &amp;  &amp; \\\\</span>
<span class="sd">                            &amp;  &amp;  &amp;  &amp;  &amp; \\Sigma \\frac{\\delta P_{r}}{\\delta x}_{N-1} + \\Sigma \\frac{\\delta P_{l}}{\\delta x}_{N}  &amp;  \\\\</span>
<span class="sd">                            &amp;  &amp;  &amp;  &amp;  &amp;  &amp; \\Sigma \\frac{\\delta P_{r}}{\\delta x}_{N}</span>
<span class="sd">                        \\end{bmatrix}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">systemflux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">systemfluxfunc</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)))</span>
        <span class="c1"># internal flux</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># fixed values for selected element</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">stateleft</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delta</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">stateright</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delta</span><span class="p">])</span>
            <span class="n">grad</span> <span class="o">=</span> <span class="p">(</span><span class="n">stateright</span> <span class="o">-</span> <span class="n">stateleft</span><span class="p">)</span> <span class="o">/</span> <span class="n">L</span>

            <span class="n">totflux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">pos</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussquad</span>
            <span class="n">Svall</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">Svalr</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># calculates the selected integral approximation</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">)):</span>
                <span class="c1"># position and state gaussian integration</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xintegration</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">state_x</span> <span class="o">=</span> <span class="n">stateleft</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[</span><span class="o">-</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">stateright</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

                <span class="n">flux</span> <span class="o">=</span> <span class="p">[</span><span class="n">systemflux</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">state_x</span><span class="p">,</span> <span class="n">grad</span><span class="p">)]</span>
                <span class="n">totflux</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

                <span class="c1"># calculates gradients for spatial state dependent fluxes</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sspatflux</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">Sfunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sspatflux</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">Sval</span> <span class="o">=</span> <span class="p">[</span><span class="n">Sfunc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">state_x</span><span class="p">]</span>
                    <span class="n">dsl</span> <span class="o">=</span> <span class="p">(</span><span class="n">Sval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Sval</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delta</span>
                    <span class="n">dsr</span> <span class="o">=</span> <span class="p">(</span><span class="n">Sval</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">Sval</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delta</span>

                    <span class="c1"># distribution of flux according to gaussian integration</span>
                    <span class="n">Svall</span> <span class="o">+=</span> <span class="n">pos</span><span class="p">[</span><span class="o">-</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="o">-</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">L</span> <span class="o">*</span> <span class="n">dsl</span>
                    <span class="n">Svalr</span> <span class="o">+=</span> <span class="n">pos</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">L</span> <span class="o">*</span> <span class="n">dsr</span>

            <span class="n">dfluxl</span> <span class="o">=</span> <span class="p">(</span><span class="n">totflux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">totflux</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delta</span>
            <span class="n">dfluxr</span> <span class="o">=</span> <span class="p">(</span><span class="n">totflux</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">totflux</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delta</span>

            <span class="c1"># assign flux values to the coefficient matrix</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="n">dfluxl</span> <span class="o">+</span> <span class="n">Svall</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dfluxl</span> <span class="o">+</span> <span class="n">Svall</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="n">dfluxr</span> <span class="o">+</span> <span class="n">Svalr</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dfluxr</span> <span class="o">+</span> <span class="n">Svalr</span>

        <span class="c1"># state dependent point flux</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Spointflux</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="p">(</span><span class="n">Sfunc</span><span class="p">,</span> <span class="p">(</span><span class="n">idx_l</span><span class="p">,</span> <span class="n">idx_r</span><span class="p">,</span> <span class="n">lfac</span><span class="p">,</span> <span class="n">rfac</span><span class="p">)),</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Spointflux</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="c1"># calculate state at position by linear interpolation</span>
            <span class="n">dstates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">idx_r</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">idx_l</span><span class="p">]</span>
            <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">idx_l</span><span class="p">]</span> <span class="o">+</span> <span class="n">rfac</span> <span class="o">*</span> <span class="n">dstates</span>
            <span class="n">sfunc_s</span> <span class="o">=</span> <span class="n">Sfunc</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="n">sfunc_sd</span> <span class="o">=</span> <span class="n">Sfunc</span><span class="p">(</span><span class="n">state</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delta</span><span class="p">)</span>
            <span class="n">dfunc</span> <span class="o">=</span> <span class="p">(</span><span class="n">sfunc_sd</span> <span class="o">-</span> <span class="n">sfunc_s</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delta</span>
            <span class="n">A</span><span class="p">[</span><span class="n">idx_l</span><span class="p">][</span><span class="n">idx_l</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dfunc</span> <span class="o">*</span> <span class="n">lfac</span>
            <span class="n">A</span><span class="p">[</span><span class="n">idx_r</span><span class="p">][</span><span class="n">idx_r</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dfunc</span> <span class="o">*</span> <span class="n">rfac</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">coefmatr</span> <span class="o">=</span> <span class="n">A</span></div>

<div class="viewcode-block" id="Flow1DFE.set_field1d"><a class="viewcode-back" href="../../../waterflow.flow1d.html#waterflow.flow1d.flowFE1d.Flow1DFE.set_field1d">[docs]</a>    <span class="k">def</span> <span class="nf">set_field1d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Initialize the system&#39;s discretization</span>

<span class="sd">        :py:attr:`~states` and :py:attr:`~forcing` are initialized with zeros.</span>
<span class="sd">        The Gaussian quadrature :py:attr:`~gauss_degree` is set and the</span>
<span class="sd">        system&#39;s discretization characteristics are calculated with</span>
<span class="sd">        :py:meth:`~_FE_precalc`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes : `tuple` or `list` or `numpy.ndarray`</span>
<span class="sd">            A tuple of the form (start, end, number of nodes) for a linearly</span>
<span class="sd">            spaced domain or a sequence of nodes that contains the nodal</span>
<span class="sd">            positions explicitly.</span>

<span class="sd">        degree : `int`, default is 1</span>
<span class="sd">            Set the Gaussian quadrature degree, this is equivalent to the</span>
<span class="sd">            :py:meth:`~set_gaussian_quadrature` method.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        .. warning::</span>
<span class="sd">            Make sure that the positions of the ``nodes`` increase towards the</span>
<span class="sd">            right of the domain.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from waterflow.flow1d.flowFE1d import Flow1DFE</span>
<span class="sd">        &gt;&gt;&gt; from waterflow.utility.spacing import biasedspacing</span>

<span class="sd">        Linear nodal spacing with a non-default Gaussian degree.</span>

<span class="sd">        &gt;&gt;&gt; FE = Flow1DFE(&quot;Several spacings&quot;)</span>
<span class="sd">        &gt;&gt;&gt; FE.set_field1d((-10, 0, 11), degree=3)</span>
<span class="sd">        &gt;&gt;&gt; FE.nodes</span>
<span class="sd">        array([-10.,  -9.,  -8.,  -7.,  -6.,  -5.,  -4.,  -3.,  -2.,  -1.,   0.])</span>
<span class="sd">        &gt;&gt;&gt; FE._xgauss</span>
<span class="sd">        (0.1127016653792583, 0.5, 0.8872983346207417)</span>

<span class="sd">        Unstructured nodes using the</span>
<span class="sd">        :py:func:`~waterflow.utility.spacing.biasedspacing` function.</span>

<span class="sd">        &gt;&gt;&gt; unstructured_nodes = biasedspacing(numnodes=11, power=4, lb=-1, rb=0, maxdist=2, length=10)</span>
<span class="sd">        &gt;&gt;&gt; FE.set_field1d(unstructured_nodes)</span>
<span class="sd">        &gt;&gt;&gt; FE.nodes</span>
<span class="sd">        array([-10.        ,  -9.61405656,  -9.29864794,  -8.94730706,</span>
<span class="sd">                -8.54868046,  -8.0844499 ,  -7.12803197,  -6.        ,</span>
<span class="sd">                -4.        ,  -2.        ,   0.        ])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">*</span><span class="n">nodes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_gaussian_quadrature</span><span class="p">(</span><span class="n">degree</span><span class="o">=</span><span class="n">degree</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_FE_precalc</span><span class="p">()</span></div>

<div class="viewcode-block" id="Flow1DFE.set_systemfluxfunction"><a class="viewcode-back" href="../../../waterflow.flow1d.html#waterflow.flow1d.flowFE1d.Flow1DFE.set_systemfluxfunction">[docs]</a>    <span class="k">def</span> <span class="nf">set_systemfluxfunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Implement the governing flow equation</span>

<span class="sd">        The :py:attr:`~systemfluxfunc` is set with the governing flow</span>
<span class="sd">        equation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        function : `func`</span>
<span class="sd">            Flow equation that takes position, state and gradient of state as</span>
<span class="sd">            its arguments respectively.</span>
<span class="sd">        **kwargs : `keyword arguments`</span>
<span class="sd">            Extra arguments for the flow equation which are implemented</span>
<span class="sd">            as defaults so that the calling signature of the flow equation</span>
<span class="sd">            remains the same.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from waterflow.flow1d.flowFE1d import Flow1DFE</span>
<span class="sd">        &gt;&gt;&gt; from waterflow.utility import fluxfunctions as fluxf</span>
<span class="sd">        &gt;&gt;&gt; from waterflow.utility import conductivityfunctions as condf</span>
<span class="sd">        &gt;&gt;&gt; from waterflow.utility.helper import initializer</span>

<span class="sd">        Implement the Richards equation for unsturated flow, herein the</span>
<span class="sd">        Van Genuchten conductivity function is used, :cite:`VanGenuchten1980`.</span>
<span class="sd">        Soil 13, &#39;loam&#39;, from De Staringreeks :cite:`Wosten2001` is selected.</span>
<span class="sd">        See :py:func:`~waterflow.utility.fluxfunctions.richards_equation` for</span>
<span class="sd">        the full definition of the fluxfunction.</span>

<span class="sd">        &gt;&gt;&gt; s, *_ = condf.soilselector([13])[0]</span>
<span class="sd">        &gt;&gt;&gt; kfun = initializer(condf.VG_conductivity, ksat=s.ksat, a=s.alpha, n=s.n)</span>
<span class="sd">        &gt;&gt;&gt; richards = fluxf.richards_equation</span>
<span class="sd">        &gt;&gt;&gt; FErichard = Flow1DFE(&quot;Flow equations&quot;)</span>
<span class="sd">        &gt;&gt;&gt; FErichard.set_systemfluxfunction(richards, kfun=kfun)</span>

<span class="sd">        For saturated flow the Darcy equation with a constant saturated</span>
<span class="sd">        conductivity can be used :cite:`Darcy1856`. See</span>
<span class="sd">        :py:func:`~waterflow.utility.fluxfunctions.darcy` for the full</span>
<span class="sd">        definition of the fluxfunction.</span>

<span class="sd">        &gt;&gt;&gt; darcy = fluxf.darcy</span>
<span class="sd">        &gt;&gt;&gt; FEdarcy = Flow1DFE(&quot;Flow equations&quot;)</span>
<span class="sd">        &gt;&gt;&gt; FEdarcy.set_systemfluxfunction(darcy, ksat=s.ksat)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">fluxfunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">gradient</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">gradient</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">systemfluxfunc</span> <span class="o">=</span> <span class="n">fluxfunction</span></div>

<div class="viewcode-block" id="Flow1DFE.set_initial_states"><a class="viewcode-back" href="../../../waterflow.flow1d.html#waterflow.flow1d.flowFE1d.Flow1DFE.set_initial_states">[docs]</a>    <span class="k">def</span> <span class="nf">set_initial_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">states</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set the initial states</span>

<span class="sd">        Although the main purpose of this method is to set the initial states</span>
<span class="sd">        it can be used to manipulate the states at any given point in time. The</span>
<span class="sd">        states are written to :py:attr:`~states`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        states : `int` or `float` or `list` or `numpy.ndarray`</span>
<span class="sd">            Set the states to an uniform value or vary the states with a</span>
<span class="sd">            sequence like argument.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        .. note::</span>
<span class="sd">            Note that the states can only be set when the discretization of</span>
<span class="sd">            the system is known.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Set the initial states of the system or use the default setting.</span>

<span class="sd">        &gt;&gt;&gt; from waterflow.flow1d.flowFE1d import Flow1DFE</span>
<span class="sd">        &gt;&gt;&gt; FE = Flow1DFE(&quot;Setting states&quot;)</span>
<span class="sd">        &gt;&gt;&gt; FE.set_field1d((-10, 0, 11))</span>
<span class="sd">        &gt;&gt;&gt; FE.states</span>
<span class="sd">        array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])</span>
<span class="sd">        &gt;&gt;&gt; FE.set_initial_states([-i for i in range(11)])</span>
<span class="sd">        &gt;&gt;&gt; FE.states</span>
<span class="sd">        array([  0.,  -1.,  -2.,  -3.,  -4.,  -5.,  -6.,  -7.,  -8.,  -9., -10.])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">states</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">states</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">states</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">states</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">))])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">states</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span></div>

<div class="viewcode-block" id="Flow1DFE.add_dirichlet_BC"><a class="viewcode-back" href="../../../waterflow.flow1d.html#waterflow.flow1d.flowFE1d.Flow1DFE.add_dirichlet_BC">[docs]</a>    <span class="k">def</span> <span class="nf">add_dirichlet_BC</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">where</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set boundary condition with fixed state</span>

<span class="sd">        The Dirichlet boundary condition is implemented with this</span>
<span class="sd">        method. The boundary condition is saved in :py:attr:`~BCs`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : `int` or `float`</span>
<span class="sd">            State value of the specific boundary</span>
<span class="sd">        where : `str`</span>
<span class="sd">            Position where the boundary condition will be set. Choose from</span>
<span class="sd">            &quot;west&quot;, &quot;left&quot;, &quot;down&quot;, &quot;east&quot;, &quot;right&quot; or &quot;up&quot;. This argument</span>
<span class="sd">            is case insensitive.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Describe how the boundary condition is implemented. !!!!!!!!!!!!!</span>
<span class="sd">        In which attrs ?</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from waterflow.flow1d.flowFE1d import Flow1DFE</span>
<span class="sd">        &gt;&gt;&gt; FE = Flow1DFE(&quot;Dirichlet boundary conditions&quot;)</span>
<span class="sd">        &gt;&gt;&gt; FE.set_field1d((-10, 0, 11))</span>
<span class="sd">        &gt;&gt;&gt; FE.BCs</span>
<span class="sd">        {}</span>
<span class="sd">        &gt;&gt;&gt; FE.add_dirichlet_BC(-100, &quot;Up&quot;)</span>
<span class="sd">        &gt;&gt;&gt; FE.add_dirichlet_BC(0, &quot;Down&quot;)</span>
<span class="sd">        &gt;&gt;&gt; FE.BCs</span>
<span class="sd">        {&#39;east&#39;: (-100, &#39;Dirichlet&#39;, -1), &#39;west&#39;: (0, &#39;Dirichlet&#39;, 0)}</span>

<span class="sd">        .. note::</span>
<span class="sd">            Note that a new boundary condition will overwrite an existing</span>
<span class="sd">            one without a warning.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span>
            <span class="n">where</span> <span class="o">=</span> <span class="p">[</span><span class="n">where</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">where</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">pos</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;west&quot;</span><span class="p">,</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;down&quot;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">BCs</span><span class="p">[</span><span class="s2">&quot;west&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="s2">&quot;Dirichlet&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_west</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">pos</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;east&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="s2">&quot;up&quot;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">BCs</span><span class="p">[</span><span class="s2">&quot;east&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="s2">&quot;Dirichlet&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_east</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span></div>

<div class="viewcode-block" id="Flow1DFE.add_neumann_BC"><a class="viewcode-back" href="../../../waterflow.flow1d.html#waterflow.flow1d.flowFE1d.Flow1DFE.add_neumann_BC">[docs]</a>    <span class="k">def</span> <span class="nf">add_neumann_BC</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">where</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set boundary condition with fixed flux</span>

<span class="sd">        The Neumann boundary condition is implemented with this</span>
<span class="sd">        method. The boundary condition is saved in :py:attr:`~BCs`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : `int` or `float`</span>
<span class="sd">            Flux value of the specific boundary</span>
<span class="sd">        where : `str`</span>
<span class="sd">            Position where the boundary condition will be set. Choose from</span>
<span class="sd">            &quot;west&quot;, &quot;left&quot;, &quot;down&quot;, &quot;east&quot;, &quot;right&quot; or &quot;up&quot;. This argument</span>
<span class="sd">            is case insensitive.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Describe how the boundary condition is implemented. !!!!!!!!!!!!!</span>
<span class="sd">        also note that FE.set_field1d needs to be called for the _east attr</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from waterflow.flow1d.flowFE1d import Flow1DFE</span>
<span class="sd">        &gt;&gt;&gt; FE = Flow1DFE(&quot;Neumann boundary conditions&quot;)</span>
<span class="sd">        &gt;&gt;&gt; FE.set_field1d((-10, 0, 11))</span>
<span class="sd">        &gt;&gt;&gt; FE.BCs</span>
<span class="sd">        {}</span>
<span class="sd">        &gt;&gt;&gt; FE.add_neumann_BC(-0.1, &quot;right&quot;)</span>
<span class="sd">        &gt;&gt;&gt; FE.BCs</span>
<span class="sd">        {&#39;east&#39;: (-0.1, &#39;Neumann&#39;, -1)}</span>
<span class="sd">        &gt;&gt;&gt; FE.add_neumann_BC(-0.5, &quot;up&quot;)</span>
<span class="sd">        &gt;&gt;&gt; FE.BCs</span>
<span class="sd">        {&#39;east&#39;: (-0.5, &#39;Neumann&#39;, -1)}</span>
<span class="sd">        &gt;&gt;&gt; FE.add_neumann_BC(-0.8, &quot;West&quot;)</span>
<span class="sd">        &gt;&gt;&gt; FE.BCs</span>
<span class="sd">        {&#39;east&#39;: (-0.5, &#39;Neumann&#39;, -1), &#39;west&#39;: (-0.8, &#39;Neumann&#39;, 0)}</span>

<span class="sd">        .. note::</span>
<span class="sd">            Note that a new boundary condition will overwrite an existing</span>
<span class="sd">            one without a warning. This method will allow both boundaries</span>
<span class="sd">            to be of type Neumann but remember that this won&#39;t be useful</span>
<span class="sd">            because of the infinite amount of solutions in such a situation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span>
            <span class="n">where</span> <span class="o">=</span> <span class="p">[</span><span class="n">where</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">where</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">pos</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;west&quot;</span><span class="p">,</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;down&quot;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">BCs</span><span class="p">[</span><span class="s2">&quot;west&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="s2">&quot;Neumann&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_west</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">pos</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;east&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="s2">&quot;up&quot;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">BCs</span><span class="p">[</span><span class="s2">&quot;east&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="s2">&quot;Neumann&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_east</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span></div>

<div class="viewcode-block" id="Flow1DFE.remove_BC"><a class="viewcode-back" href="../../../waterflow.flow1d.html#waterflow.flow1d.flowFE1d.Flow1DFE.remove_BC">[docs]</a>    <span class="k">def</span> <span class="nf">remove_BC</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Remove boundary conditions</span>

<span class="sd">        Calling this method with default arguments will clear all boundary</span>
<span class="sd">        conditions set. To clear a specific boundary condition the name</span>
<span class="sd">        needs to be passed explicitly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *args : `str`, optional</span>
<span class="sd">            The positional arguments should contain the name of the boundary</span>
<span class="sd">            conditions as saved in :py:attr:`~BCs`. This can be &quot;west&quot; or</span>
<span class="sd">            &quot;east&quot;.</span>

<span class="sd">        Raises</span>
<span class="sd">        -----</span>
<span class="sd">        KeyError</span>
<span class="sd">            This exception is raised when ``*args`` contains an invalid</span>
<span class="sd">            boundary condition name which does not occur in the system.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        .. note::</span>
<span class="sd">            This is the safe way to remove the boundary conditions because it</span>
<span class="sd">            will also handle and reset the :py:attr:`~_west` and</span>
<span class="sd">            :py:attr:`~_east` attributes which are associated with the</span>
<span class="sd">            implementation of the boundary conditions in the numerical scheme.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from waterflow.flow1d.flowFE1d import Flow1DFE</span>
<span class="sd">        &gt;&gt;&gt; FE = Flow1DFE(&quot;Boundary condition removal&quot;)</span>
<span class="sd">        &gt;&gt;&gt; FE.set_field1d((-10, 0, 11))</span>
<span class="sd">        &gt;&gt;&gt; FE.add_dirichlet_BC(-100, &quot;up&quot;)</span>
<span class="sd">        &gt;&gt;&gt; FE.add_neumann_BC(0.0, &quot;down&quot;)</span>
<span class="sd">        &gt;&gt;&gt; FE.BCs</span>
<span class="sd">        {&#39;east&#39;: (-100, &#39;Dirichlet&#39;, -1), &#39;west&#39;: (0.0, &#39;Neumann&#39;, 0)}</span>
<span class="sd">        &gt;&gt;&gt; FE.remove_BC(&quot;right&quot;)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">         ...</span>
<span class="sd">        KeyError: &#39;No boundary named right.&#39;</span>
<span class="sd">        &gt;&gt;&gt; FE.remove_BC(&quot;west&quot;)</span>
<span class="sd">        &gt;&gt;&gt; FE.BCs</span>
<span class="sd">        {&#39;east&#39;: (-100, &#39;Dirichlet&#39;, -1)}</span>
<span class="sd">        &gt;&gt;&gt; FE.remove_BC()</span>
<span class="sd">        &gt;&gt;&gt; FE.BCs</span>
<span class="sd">        {}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">BCs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_west</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_east</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">BCs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;west&quot;</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_west</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_east</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)(</span><span class="s2">&quot;No boundary named &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Flow1DFE.add_pointflux"><a class="viewcode-back" href="../../../waterflow.flow1d.html#waterflow.flow1d.flowFE1d.Flow1DFE.add_pointflux">[docs]</a>    <span class="k">def</span> <span class="nf">add_pointflux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add a pointflux to the system</span>

<span class="sd">        Pointflux values and pointflux functions are accepted. Multiple</span>
<span class="sd">        point fluxes can be combined in a list. Scalar pointflux values</span>
<span class="sd">        are accumulated to its local matrix :math:`F` at the correct indices.</span>
<span class="sd">        The state dependent pointflux functions are prepared and saved for</span>
<span class="sd">        calculation in a context where :math:`s` is available.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rate : `float`, `int`, `list` or `func`</span>
<span class="sd">            *   Scalar pointflux value(s).</span>
<span class="sd">            *   Pointflux function of the form :math:`P(s)`.</span>
<span class="sd">        pos : `float`, `int` or `list`</span>
<span class="sd">            Position(s) of the pointflux value(s)/function.</span>
<span class="sd">        name : `str`, default is None</span>
<span class="sd">            Name of the pointflux. If omitted, a unique key is</span>
<span class="sd">            generated for a scalar pointflux or the string version</span>
<span class="sd">            of the pointflux function is used.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        :math:`node_{r}` is the index of the right node that is nearest</span>
<span class="sd">        the position of the pointflux and is calculated by</span>
<span class="sd">        :py:meth:`~numpy.searchsorted`. :math:`node_{l} = node_{r} - 1`,</span>
<span class="sd">        which is the left node that is most near the position of the pointflux.</span>

<span class="sd">        :math:`lfac` and :math:`rfac` represent the fractions of the pointflux</span>
<span class="sd">        that contribute to the nearest left and right node repectively.</span>

<span class="sd">        .. math::</span>
<span class="sd">            lfac = 1 - (pos - x_{node_{l}}) / (x_{node_{r}} - x_{node_{l}})</span>

<span class="sd">        .. math::</span>
<span class="sd">            rfac = 1 - lfac</span>

<span class="sd">        In case of a scalar pointflux the distributed values are assigned to</span>
<span class="sd">        its local forcing array at the correct nodal positions and saved in</span>
<span class="sd">        :py:attr:`~pointflux`. See the formulas below:</span>

<span class="sd">        .. math::</span>
<span class="sd">            F_{node_{l}} = rate * lfac</span>

<span class="sd">        .. math::</span>
<span class="sd">            F_{node_{r}} = rate * rfac</span>

<span class="sd">        For the state dependent pointflux function the calculated values of</span>
<span class="sd">        :math:`node_{l}`, :math:`node_{r}`, :math:`lfac`, and :math:`rfac` are</span>
<span class="sd">        saved in :py:attr:`~Spointflux` in addition to the state dependent</span>
<span class="sd">        pointflux function itself and an empty local forcing array :math:`F`.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            Multiple functions, unlike scalar point fluxes, should be</span>
<span class="sd">            implemented separately and cannot be combined in a list argument.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from waterflow.flow1d.flowFE1d import Flow1DFE</span>
<span class="sd">        &gt;&gt;&gt; FE = Flow1DFE(&quot;Point fluxes&quot;)</span>
<span class="sd">        &gt;&gt;&gt; FE.set_field1d((-10, 0, 11))</span>

<span class="sd">        &gt;&gt;&gt; # Add a scalar pointflux</span>
<span class="sd">        &gt;&gt;&gt; FE.add_pointflux(-0.003, -5.5, &#39;pflux&#39;)</span>
<span class="sd">        &gt;&gt;&gt; FE.pointflux</span>
<span class="sd">        {&#39;pflux&#39;: [array([ 0.    ,  0.    ,  0.    ,  0.    , -0.0015, -0.0015,  0.    ,</span>
<span class="sd">                0.    ,  0.    ,  0.    ,  0.    ])]}</span>

<span class="sd">        &gt;&gt;&gt; # Define a state dependent point flux function</span>
<span class="sd">        &gt;&gt;&gt; def Spflux(s):</span>
<span class="sd">        ...     return abs(np.sin(s)) * -0.1</span>
<span class="sd">        &gt;&gt;&gt; FE.add_pointflux(Spflux, -3.1)</span>
<span class="sd">        &gt;&gt;&gt; FE.Spointflux #doctest: +ELLIPSIS</span>
<span class="sd">        {&#39;Spflux&#39;: [(&lt;function Spflux at 0x...&gt;, (6, 7, 0.10000000000000009, 0.8999999999999999)), array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])]}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="mf">0.0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">))]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rate</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rate</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">rate</span> <span class="o">=</span> <span class="p">[</span><span class="n">rate</span><span class="p">]</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="p">[</span><span class="n">pos</span><span class="p">]</span>

        <span class="c1"># add single valued pointflux to corresponding control volume</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rate</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rate</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
                <span class="c1"># find indices left and right of pointflux</span>
                <span class="n">idx_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
                <span class="n">idx_l</span> <span class="o">=</span> <span class="n">idx_r</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="c1"># calculate contribution of pointflux to neighbouring nodes</span>
                <span class="n">nodedist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">idx_r</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">idx_l</span><span class="p">]</span>
                <span class="n">lfactor</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">idx_l</span><span class="p">])</span> <span class="o">/</span> <span class="n">nodedist</span>
                <span class="n">rfactor</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lfactor</span>
                <span class="c1"># assign to the forcing vector</span>
                <span class="n">f</span><span class="p">[</span><span class="n">idx_l</span><span class="p">]</span> <span class="o">+=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">lfactor</span>
                <span class="n">f</span><span class="p">[</span><span class="n">idx_r</span><span class="p">]</span> <span class="o">+=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">rfactor</span>

            <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pointflux</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">Time</span><span class="o">.</span><span class="n">time</span><span class="p">())</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pointflux</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">)]</span>

        <span class="c1"># add state dependent pointflux</span>
        <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">rate</span><span class="p">):</span>
            <span class="c1"># find indices left and right of pointflux</span>
            <span class="n">idx_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
            <span class="n">idx_l</span> <span class="o">=</span> <span class="n">idx_r</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="c1"># calculate contribution of pointflux to neighbouring nodes</span>
            <span class="n">nodedist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">idx_r</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">idx_l</span><span class="p">]</span>
            <span class="n">lfactor</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">idx_l</span><span class="p">])</span> <span class="o">/</span> <span class="n">nodedist</span>
            <span class="n">rfactor</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lfactor</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">rate</span><span class="o">.</span><span class="vm">__name__</span>

            <span class="c1"># create data structure</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Spointflux</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">rate</span><span class="p">,</span> <span class="p">(</span><span class="n">idx_l</span><span class="p">,</span> <span class="n">idx_r</span><span class="p">,</span> <span class="n">lfactor</span><span class="p">,</span> <span class="n">rfactor</span><span class="p">)),</span>
                                     <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">)]</span></div>

<div class="viewcode-block" id="Flow1DFE.add_spatialflux"><a class="viewcode-back" href="../../../waterflow.flow1d.html#waterflow.flow1d.flowFE1d.Flow1DFE.add_spatialflux">[docs]</a>    <span class="k">def</span> <span class="nf">add_spatialflux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add a spatialflux to the system</span>

<span class="sd">        Spatial fluxes of several types are accepted by this method.</span>
<span class="sd">        Direct calculation of the forcing values is performed where</span>
<span class="sd">        possible. State dependent forcing functions will be</span>
<span class="sd">        calculated in a different context. The storage change function</span>
<span class="sd">        for the simulation of a transient system should be implemented</span>
<span class="sd">        here.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        q : `int`, `float`, `list` or `func`</span>
<span class="sd">            * Scalar spatial flux value applied over the complete domain.</span>
<span class="sd">            * Sequence of different spatial flux values for every nodal</span>
<span class="sd">              position.</span>
<span class="sd">            * Positional and/or state dependent spatial flux function.</span>
<span class="sd">            * Storage change function for a transient simulation.</span>
<span class="sd">        name : `str`, default is None</span>
<span class="sd">            Name of the spatialflux. If omitted, a unique key is</span>
<span class="sd">            generated for a scalar/sequence like spatialflux or the string</span>
<span class="sd">            version of the spatialflux function is used.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        When ``q`` is a scalar or sequence like argument the local forcing</span>
<span class="sd">        array :math:`F_{local}` is calculated by multiplication with the</span>
<span class="sd">        corresponding lengths and will be saved in :py:attr:`~spatflux`.</span>

<span class="sd">        .. math::</span>
<span class="sd">            F_{local} = q * nL</span>

<span class="sd">        If ``q`` is a function of position, :math:`S(x)`, the flux is</span>
<span class="sd">        calculated per segment. Below the exact definition of this calculation</span>
<span class="sd">        is presented, taking into account the Gaussian quadrature degree</span>
<span class="sd">        :math:`\\Lambda`.</span>

<span class="sd">        .. math::</span>
<span class="sd">            F_{l_{i}} = \\sum_{\\lambda =1}^{\\Lambda} S(X_{i, \\lambda}) * (1-p_{\\lambda}) * w_{\\lambda} * L_{i}</span>

<span class="sd">        .. math::</span>
<span class="sd">            F_{r_{i}} = \\sum_{\\lambda =1}^{\\Lambda} S(X_{i, \\lambda}) * p_{\\lambda} * w_{\\lambda} * L_{i}</span>

<span class="sd">        After the calculation of the distribution towards the nearest nodes the</span>
<span class="sd">        local forcing matrix :math:`F_{local}` is populated and will be saved</span>
<span class="sd">        in :py:attr:`~spatflux`.</span>

<span class="sd">        .. math::</span>
<span class="sd">            F_{local} = \\begin{bmatrix}</span>
<span class="sd">                            F_{l_{i}}                   \\\\</span>
<span class="sd">                            F_{r_{i}} + F_{l_{i+1}}     \\\\</span>
<span class="sd">                            F_{r_{i+1}} + F_{l_{i+2}}   \\\\</span>
<span class="sd">                            \\vdots                     \\\\</span>
<span class="sd">                            F_{r_{N-1}} + F_{l_{N}}     \\\\</span>
<span class="sd">                            F_{r_{N}}</span>
<span class="sd">                        \\end{bmatrix}</span>

<span class="sd">        In the case of ``q`` being a function of position and state,</span>
<span class="sd">        :math:`S(x, s)`, the function will be assigned to :py:attr:`~Sspatflux`</span>
<span class="sd">        for later processing in a context where :math:`s` is available.</span>

<span class="sd">        ``q`` can have four arguments, :math:`S(x, s, prevstate, dt)`. This is</span>
<span class="sd">        a special case reserved for the storage change function.</span>
<span class="sd">        The function signature may have keyword arguments but they need to</span>
<span class="sd">        be optional having a default value. See a possible definition of</span>
<span class="sd">        a storage change function,</span>
<span class="sd">        :py:func:`~waterflow.utility.fluxfunctions.storage_change`, that can</span>
<span class="sd">        be used for both saturated and unsaturated conditions depending on its</span>
<span class="sd">        default keyword arguments. The storage change function is saved in</span>
<span class="sd">        :py:attr:`~Sspatflux` and will carry the default name &#39;storage_change&#39;,</span>
<span class="sd">        see the last example.</span>

<span class="sd">        .. note::</span>
<span class="sd">            For spatial state dependent flux functions the function signature</span>
<span class="sd">            will always look like :math:`S(x, s)` whether there is a</span>
<span class="sd">            positional dependency or not. This is needed to distinguish between</span>
<span class="sd">            the :math:`x` and :math:`s` arguments.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from waterflow.flow1d.flowFE1d import Flow1DFE</span>
<span class="sd">        &gt;&gt;&gt; from waterflow.utility.fluxfunctions import storage_change</span>
<span class="sd">        &gt;&gt;&gt; FE = Flow1DFE(&quot;spatial fluxes&quot;)</span>
<span class="sd">        &gt;&gt;&gt; FE.set_field1d((-10, 0, 11))</span>

<span class="sd">        &gt;&gt;&gt; # Add a scalar spatialflux</span>
<span class="sd">        &gt;&gt;&gt; FE.add_spatialflux(-0.001, &#39;Root extraction&#39;)</span>
<span class="sd">        &gt;&gt;&gt; FE.spatflux</span>
<span class="sd">        {&#39;Root extraction&#39;: [array([-0.0005, -0.001 , -0.001 , -0.001 , -0.001 , -0.001 , -0.001 ,</span>
<span class="sd">               -0.001 , -0.001 , -0.001 , -0.0005])]}</span>

<span class="sd">        &gt;&gt;&gt; # Add position dependent spatial flux function</span>
<span class="sd">        &gt;&gt;&gt; def linear_extraction(x):</span>
<span class="sd">        ...     return -0.001 * abs(x)</span>
<span class="sd">        &gt;&gt;&gt; FE.add_spatialflux(linear_extraction)</span>
<span class="sd">        &gt;&gt;&gt; FE.spatflux</span>
<span class="sd">        {&#39;Root extraction&#39;: [array([-0.0005, -0.001 , -0.001 , -0.001 , -0.001 , -0.001 , -0.001 ,</span>
<span class="sd">               -0.001 , -0.001 , -0.001 , -0.0005])], &#39;linear_extraction&#39;: [array([-0.00475, -0.009  , -0.008  , -0.007  , -0.006  , -0.005  ,</span>
<span class="sd">               -0.004  , -0.003  , -0.002  , -0.001  , -0.00025])]}</span>

<span class="sd">        &gt;&gt;&gt; # Add position and state dependent spatial flux function</span>
<span class="sd">        &gt;&gt;&gt; def linear_s_extraction(x, s):</span>
<span class="sd">        ...     return -0.001 * x - 0.001 * s</span>
<span class="sd">        &gt;&gt;&gt; FE.add_spatialflux(linear_s_extraction, &#39;Sfunc&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # Note that the local forcing array will always be empty and is only initialized</span>
<span class="sd">        &gt;&gt;&gt; FE.Sspatflux #doctest: +ELLIPSIS</span>
<span class="sd">        {&#39;Sfunc&#39;: [&lt;function linear_s_extraction at 0x...&gt;, array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])]}</span>

<span class="sd">        &gt;&gt;&gt; # The storage change function is imported and passed to the model</span>
<span class="sd">        &gt;&gt;&gt; # note that the name argument is ignored.</span>
<span class="sd">        &gt;&gt;&gt; FE.add_spatialflux(storage_change, name=&#39;My_storage_change&#39;)</span>
<span class="sd">        &gt;&gt;&gt; FE.Sspatflux #doctest: +ELLIPSIS</span>
<span class="sd">        {&#39;Sfunc&#39;: [&lt;function linear_s_extraction at 0x...&gt;, array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])], &#39;storage_change&#39;: [&lt;function storage_change at 0x...&gt;, array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])]}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">q</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">Q</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">Q</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lengths</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">Time</span><span class="o">.</span><span class="n">time</span><span class="p">())</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">spatflux</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">)]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># prepare a domain spaced and zero-ed array</span>
            <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="mf">0.0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">))]</span>

            <span class="c1"># check callable&#39;s number of positional arguments</span>
            <span class="n">fparams</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span>
            <span class="n">nargs</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">fparams</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="vm">__name__</span>

            <span class="c1"># if function has one argument &gt; f(x)</span>
            <span class="k">if</span> <span class="n">nargs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">pos</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussquad</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="c1"># distance between nodes</span>
                    <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seg_lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">)):</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xintegration</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
                        <span class="c1"># to left node (no pos negatives?)</span>
                        <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="o">-</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[</span><span class="o">-</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">L</span>
                        <span class="c1"># to right node</span>
                        <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">L</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spatflux</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">)]</span>

            <span class="c1"># if function has two arguments &gt; f(x,s)</span>
            <span class="k">elif</span> <span class="n">nargs</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Sspatflux</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">Q</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">)]</span>

            <span class="k">elif</span> <span class="n">nargs</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="c1"># implement time dependence ??</span>
                <span class="k">pass</span>

            <span class="c1"># only valid for the storage change function</span>
            <span class="c1"># f(x, s, prevstate, dt)</span>
            <span class="k">elif</span> <span class="n">nargs</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;storage_change&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Sspatflux</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">Q</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">)]</span></div>

<div class="viewcode-block" id="Flow1DFE.remove_pointflux"><a class="viewcode-back" href="../../../waterflow.flow1d.html#waterflow.flow1d.flowFE1d.Flow1DFE.remove_pointflux">[docs]</a>    <span class="k">def</span> <span class="nf">remove_pointflux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Remove point fluxes</span>

<span class="sd">        Remove all or a specific point fluxes. When this method is called</span>
<span class="sd">        with default arguments all point fluxes will be removed from both</span>
<span class="sd">        :py:attr:`~pointflux` and :py:attr:`~Spointflux`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *args : `str`, optional</span>
<span class="sd">            Name(s) of specific point fluxes.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        KeyError</span>
<span class="sd">            Will be raised when the name of the pointflux does not exists.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from waterflow.flow1d.flowFE1d import Flow1DFE</span>
<span class="sd">        &gt;&gt;&gt; FE = Flow1DFE(&quot;Point flux removal&quot;)</span>
<span class="sd">        &gt;&gt;&gt; FE.set_field1d((-10, 0, 11))</span>

<span class="sd">        &gt;&gt;&gt; # Add a scalar pointflux</span>
<span class="sd">        &gt;&gt;&gt; FE.add_pointflux(-0.001, -3.3, &#39;Point1&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # Add an other</span>
<span class="sd">        &gt;&gt;&gt; FE.add_pointflux(-0.002, -5.5, &#39;Point2&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # Add a third</span>
<span class="sd">        &gt;&gt;&gt; FE.add_pointflux(-0.003, -7.7, &#39;Point3&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # Check for all the currently available pointflux names</span>
<span class="sd">        &gt;&gt;&gt; FE.pointflux.keys()</span>
<span class="sd">        dict_keys([&#39;Point1&#39;, &#39;Point2&#39;, &#39;Point3&#39;])</span>
<span class="sd">        &gt;&gt;&gt; def Spflux(s):</span>
<span class="sd">        ...     return abs(np.sin(s)) * -0.1</span>
<span class="sd">        &gt;&gt;&gt; FE.add_pointflux(Spflux, -6.6)</span>
<span class="sd">        &gt;&gt;&gt; FE.Spointflux.keys()</span>
<span class="sd">        dict_keys([&#39;Spflux&#39;])</span>

<span class="sd">        &gt;&gt;&gt; # Specific removal of the point fluxes</span>
<span class="sd">        &gt;&gt;&gt; FE.remove_pointflux(&#39;Point1&#39;, &#39;Point3&#39;)</span>
<span class="sd">        &gt;&gt;&gt; FE.pointflux.keys()</span>
<span class="sd">        dict_keys([&#39;Point2&#39;])</span>
<span class="sd">        &gt;&gt;&gt; # Use an incorrect name</span>
<span class="sd">        &gt;&gt;&gt; FE.remove_pointflux(&quot;Point4&quot;) #doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        KeyError: &quot;&#39;Point4&#39; is not a pointflux.&quot;</span>
<span class="sd">        &gt;&gt;&gt; # Remove the remaining point fluxes</span>
<span class="sd">        &gt;&gt;&gt; FE.remove_pointflux()</span>
<span class="sd">        &gt;&gt;&gt; FE.pointflux</span>
<span class="sd">        {}</span>
<span class="sd">        &gt;&gt;&gt; FE.Spointflux</span>
<span class="sd">        {}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># remove all point fluxes</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pointflux</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Spointflux</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># remove the specific pointflux name(s)</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pointflux</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Spointflux</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="c1"># Only raise exception at top of call stack</span>
                        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> is not a pointflux.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">))</span> <span class="kn">from</span> <span class="nn">None</span></div>

<div class="viewcode-block" id="Flow1DFE.remove_spatialflux"><a class="viewcode-back" href="../../../waterflow.flow1d.html#waterflow.flow1d.flowFE1d.Flow1DFE.remove_spatialflux">[docs]</a>    <span class="k">def</span> <span class="nf">remove_spatialflux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Remove spatial fluxes</span>

<span class="sd">        Remove all or a specific spatial fluxes. When this method is called</span>
<span class="sd">        with default arguments all spatial fluxes will be removed from both</span>
<span class="sd">        :py:attr:`~spatflux` and :py:attr:`~Sspatflux`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *args : `str`, optional</span>
<span class="sd">            Name(s) of specific spatial fluxes.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        KeyError</span>
<span class="sd">            Will be raised when the name of the spatialflux does not exists.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from waterflow.flow1d.flowFE1d import Flow1DFE</span>
<span class="sd">        &gt;&gt;&gt; from waterflow.utility.fluxfunctions import storage_change</span>
<span class="sd">        &gt;&gt;&gt; FE = Flow1DFE(&quot;Spatial flux removal&quot;)</span>
<span class="sd">        &gt;&gt;&gt; FE.set_field1d((-10, 0, 11))</span>

<span class="sd">        &gt;&gt;&gt; # Add a scalar spatialflux</span>
<span class="sd">        &gt;&gt;&gt; FE.add_spatialflux(-0.001, &#39;Spat1&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # Add an other</span>
<span class="sd">        &gt;&gt;&gt; FE.add_spatialflux(-0.002, &#39;Spat2&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # Add a third</span>
<span class="sd">        &gt;&gt;&gt; FE.add_spatialflux(-0.003, &#39;Spat3&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # Check for all the currently available spatialflux names</span>
<span class="sd">        &gt;&gt;&gt; FE.spatflux.keys()</span>
<span class="sd">        dict_keys([&#39;Spat1&#39;, &#39;Spat2&#39;, &#39;Spat3&#39;])</span>
<span class="sd">        &gt;&gt;&gt; # Add the storage change function</span>
<span class="sd">        &gt;&gt;&gt; FE.add_spatialflux(storage_change)</span>
<span class="sd">        &gt;&gt;&gt; # Check which spatial state dependent flux function is saved</span>
<span class="sd">        &gt;&gt;&gt; FE.Sspatflux.keys()</span>
<span class="sd">        dict_keys([&#39;storage_change&#39;])</span>

<span class="sd">        &gt;&gt;&gt; # Specific removal of the spatial fluxes</span>
<span class="sd">        &gt;&gt;&gt; FE.remove_spatialflux(&quot;Spat1&quot;, &quot;Spat2&quot;)</span>
<span class="sd">        &gt;&gt;&gt; FE.spatflux.keys()</span>
<span class="sd">        dict_keys([&#39;Spat3&#39;])</span>
<span class="sd">        &gt;&gt;&gt; # Use an incorrect name</span>
<span class="sd">        &gt;&gt;&gt; FE.remove_spatialflux(&quot;Spat4&quot;) #doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        KeyError: &quot;&#39;Spat4&#39; is not a spatialflux.&quot;</span>
<span class="sd">        &gt;&gt;&gt; # Remove the remaining spatial fluxes</span>
<span class="sd">        &gt;&gt;&gt; FE.remove_spatialflux()</span>
<span class="sd">        &gt;&gt;&gt; FE.spatflux</span>
<span class="sd">        {}</span>
<span class="sd">        &gt;&gt;&gt; FE.Sspatflux</span>
<span class="sd">        {}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># remove all spatial fluxes when args is empty</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spatflux</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Sspatflux</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># remove the given spatial flux name(s)</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">spatflux</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Sspatflux</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="c1"># Only raise exception at top of call stack</span>
                        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> is not a spatialflux.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">))</span> <span class="kn">from</span> <span class="nn">None</span></div>

<div class="viewcode-block" id="Flow1DFE.states_to_function"><a class="viewcode-back" href="../../../waterflow.flow1d.html#waterflow.flow1d.flowFE1d.Flow1DFE.states_to_function">[docs]</a>    <span class="k">def</span> <span class="nf">states_to_function</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Prepare one-dimensional interpolation function</span>

<span class="sd">        One-dimensional piecewise linearly interpolated function which returns</span>
<span class="sd">        the system&#39;s states and is continiously defined on the domain</span>
<span class="sd">        :py:attr:`~nodes`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `functools.partial`</span>
<span class="sd">            Function that calculates the system&#39;s states for a given position.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from waterflow.flow1d.flowFE1d import Flow1DFE</span>
<span class="sd">        &gt;&gt;&gt; FE = Flow1DFE(&quot;Continiously defined states&quot;)</span>
<span class="sd">        &gt;&gt;&gt; FE.set_field1d((-10, 0, 11))</span>
<span class="sd">        &gt;&gt;&gt; FE.set_initial_states([-i for i in range(11)])</span>
<span class="sd">        &gt;&gt;&gt; continious_states = FE.states_to_function()</span>
<span class="sd">        &gt;&gt;&gt; # On a boundary node</span>
<span class="sd">        &gt;&gt;&gt; continious_states(0)</span>
<span class="sd">        -10.0</span>
<span class="sd">        &gt;&gt;&gt; # In between two nodes</span>
<span class="sd">        &gt;&gt;&gt; continious_states(-8.5)</span>
<span class="sd">        -1.5</span>
<span class="sd">        &gt;&gt;&gt; # multiple results at once</span>
<span class="sd">        &gt;&gt;&gt; continious_states([-0.2 * i for i in range(6)])</span>
<span class="sd">        array([-10. ,  -9.8,  -9.6,  -9.4,  -9.2,  -9. ])</span>

<span class="sd">        .. warning::</span>
<span class="sd">            Be aware that the function does not raise an exception but returns</span>
<span class="sd">            the value of the nearest boundary when a position outside of the</span>
<span class="sd">            domain is given as argument.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># check if west boundary is of type Dirichlet</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_west</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BCs</span><span class="p">[</span><span class="s2">&quot;west&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># check is east boundary is of type Dirichlet</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_east</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">states</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BCs</span><span class="p">[</span><span class="s2">&quot;east&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># linearly interpolate between states including assigned boundaries</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">,</span> <span class="n">xp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">fp</span><span class="o">=</span><span class="n">states</span><span class="p">)</span></div>

<div class="viewcode-block" id="Flow1DFE.dt_solve"><a class="viewcode-back" href="../../../waterflow.flow1d.html#waterflow.flow1d.flowFE1d.Flow1DFE.dt_solve">[docs]</a>    <span class="k">def</span> <span class="nf">dt_solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Solve the system for one specific time step</span>

<span class="sd">        Performs the Newton-Raphson method, :cite:`Newton1964`, to find a</span>
<span class="sd">        solution to the system of equations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dt : `int` or `float`</span>
<span class="sd">            Time step which will be solved for.</span>
<span class="sd">        maxiter : `int`</span>
<span class="sd">            Maximum number of iterations in which the system should</span>
<span class="sd">            converge to a solution.</span>
<span class="sd">        threshold : `float`, default is 1e-3</span>
<span class="sd">            Threshold for conversion, the system has converged when the</span>
<span class="sd">            definition below is satisfied:</span>

<span class="sd">            .. math::</span>
<span class="sd">                max(abs(s_{t-1}-s_{t})) &lt; max(abs(threshold * s_{t}))</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. note::</span>
<span class="sd">            This method may also be used for stationary systems in which no</span>
<span class="sd">            time step value is given. Any value of ``dt`` can be passed</span>
<span class="sd">            because of the method being independent from this argument in</span>
<span class="sd">            such a case.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            Time step ``dt`` should not be to large. In :py:meth:`~solve`</span>
<span class="sd">            a more quantitative description of time step selection is</span>
<span class="sd">            described.</span>

<span class="sd">        **Procedure**</span>

<span class="sd">        1.  Check for proper boundary conditions (:py:meth:`~_check_boundaries`).</span>
<span class="sd">        2.  Update states function and time step size of storage change</span>
<span class="sd">            function if system is transient (:py:meth:`~_update_storage_change`).</span>
<span class="sd">        3.  Check if current iteration does not exceed ``maxiter``, otherwise return.</span>
<span class="sd">        4.  Collect all forcing in :py:attr:`~forcing`.</span>

<span class="sd">            a.  Aggregation of state independent forcing (:py:meth:`~_aggregate_forcing`).</span>
<span class="sd">            b.  Calculate the system’s internal forcing (:py:meth:`~_internal_forcing`).</span>
<span class="sd">            c.  Calculation of state dependent forcing values (:py:meth:`~_statedep_forcing`).</span>

<span class="sd">        5.  Build the jacobian matrix (:py:meth:`~_CMAT`).</span>
<span class="sd">        6.  Newton-Raphson iteration :cite:`Newton1964`.</span>

<span class="sd">            a.  :math:`A * y + F_{forcing} = 0` is solved for :math:`y` (:py:func:`~numpy.linalg.solve`).</span>
<span class="sd">            b.  :math:`y` is accumulated to :py:attr:`~states`.</span>

<span class="sd">        7. Check for convergence ``threshold``, if not satisfied proceed with</span>
<span class="sd">           next iteration from step 3.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `int`</span>
<span class="sd">            Number of iterations until system convergence or ``maxiter`` if</span>
<span class="sd">            the system has not been converged.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from waterflow.flow1d.flowFE1d import Flow1DFE</span>
<span class="sd">        &gt;&gt;&gt; from waterflow.utility import conductivityfunctions as condf</span>
<span class="sd">        &gt;&gt;&gt; from waterflow.utility import fluxfunctions as fluxf</span>
<span class="sd">        &gt;&gt;&gt; from waterflow.utility.helper import initializer</span>

<span class="sd">        Select soil 13, &#39;loam&#39;, from De Staringreeks :cite:`Wosten2001`</span>
<span class="sd">        and prepare the conductivity function and theta-h relation with the</span>
<span class="sd">        soil parameters. These functions are the arguments to the fluxfunction</span>
<span class="sd">        and the storage change function repectively.</span>

<span class="sd">        &gt;&gt;&gt; s, *_ = condf.soilselector([13])[0]</span>
<span class="sd">        &gt;&gt;&gt; theta_h = initializer(condf.VG_pressureh, theta_r=s.t_res,</span>
<span class="sd">        ...                       theta_s=s.t_sat, a=s.alpha, n=s.n)</span>
<span class="sd">        &gt;&gt;&gt; kfun = initializer(condf.VG_conductivity, ksat=s.ksat, a=s.alpha, n=s.n)</span>
<span class="sd">        &gt;&gt;&gt; storage_change = initializer(fluxf.storage_change, fun=theta_h)</span>

<span class="sd">        &gt;&gt;&gt; FE = Flow1DFE(&quot;Solve for one time step&quot;)</span>
<span class="sd">        &gt;&gt;&gt; FE.set_systemfluxfunction(fluxf.richards_equation, kfun=kfun)</span>
<span class="sd">        &gt;&gt;&gt; FE.set_field1d(nodes=(-10, 0, 11))</span>
<span class="sd">        &gt;&gt;&gt; FE.add_dirichlet_BC(0.0, &#39;west&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # Constant boundary flow of 0.3 cm/d out of the system</span>
<span class="sd">        &gt;&gt;&gt; FE.add_neumann_BC(-0.3, &#39;east&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # Solve the stationary system, independent or dt.</span>
<span class="sd">        &gt;&gt;&gt; iterations = FE.dt_solve(dt=0.0)</span>
<span class="sd">        &gt;&gt;&gt; iterations</span>
<span class="sd">        3</span>
<span class="sd">        &gt;&gt;&gt; FE.states</span>
<span class="sd">        array([  0.        ,  -1.02794815,  -2.05972769,  -3.09448033,</span>
<span class="sd">                -4.13189871,  -5.17183029,  -6.21419211,  -7.25893958,</span>
<span class="sd">                -8.30605208,  -9.35552524, -10.40736646])</span>

<span class="sd">        &gt;&gt;&gt; # Add storage change function to make the system transient</span>
<span class="sd">        &gt;&gt;&gt; FE.add_spatialflux(storage_change)</span>
<span class="sd">        &gt;&gt;&gt; # Change eastern boundary to drive a change in the system</span>
<span class="sd">        &gt;&gt;&gt; FE.add_neumann_BC(-0.4, &#39;east&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # solve for 0.01 days</span>
<span class="sd">        &gt;&gt;&gt; iterations = FE.dt_solve(dt=0.01)</span>
<span class="sd">        &gt;&gt;&gt; iterations</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; FE.states</span>
<span class="sd">        array([  0.        ,  -1.0353111 ,  -2.07549983,  -3.1195156 ,</span>
<span class="sd">                -4.16702367,  -5.21790586,  -6.27215519,  -7.32983969,</span>
<span class="sd">                -8.39108809,  -9.45608494, -10.52507089])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_boundaries</span><span class="p">()</span>
        <span class="n">west</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_west</span>
        <span class="n">east</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_east</span>

        <span class="c1"># if system is transient</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_storage_change</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states_to_function</span><span class="p">(),</span> <span class="n">dt</span><span class="p">)</span>

        <span class="n">itercount</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">itercount</span> <span class="o">&lt;=</span> <span class="n">maxiter</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_aggregate_forcing</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_internal_forcing</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_statedep_forcing</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_CMAT</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">)</span>

            <span class="n">solution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coefmatr</span><span class="p">[</span><span class="n">west</span><span class="p">:</span><span class="n">east</span><span class="p">,</span> <span class="n">west</span><span class="p">:</span><span class="n">east</span><span class="p">],</span>
                                       <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="p">[</span><span class="n">west</span><span class="p">:</span><span class="n">east</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

            <span class="n">prevstates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span>
            <span class="n">curstates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">prevstates</span><span class="p">)</span>
            <span class="n">curstates</span><span class="p">[</span><span class="n">west</span><span class="p">:</span><span class="n">east</span><span class="p">]</span> <span class="o">+=</span> <span class="n">solution</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="n">curstates</span>

            <span class="c1"># update forcing and boundaries at new states</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_aggregate_forcing</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_internal_forcing</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_statedep_forcing</span><span class="p">()</span>

            <span class="c1"># check solution for conversion</span>
            <span class="n">max_abs_change</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">prevstates</span> <span class="o">-</span> <span class="n">curstates</span><span class="p">))</span>
            <span class="n">max_abs_allowed_change</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">threshold</span> <span class="o">*</span> <span class="n">curstates</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">max_abs_change</span> <span class="o">&lt;</span> <span class="n">max_abs_allowed_change</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">itercount</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">itercount</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isinitial</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">itercount</span></div>

<div class="viewcode-block" id="Flow1DFE.solve"><a class="viewcode-back" href="../../../waterflow.flow1d.html#waterflow.flow1d.flowFE1d.Flow1DFE.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">dt_min</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">dt_max</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">end_time</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
              <span class="n">dtitlow</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">dtithigh</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">itermin</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">itermax</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span>
              <span class="n">verbosity</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Solve the system for an arbitrary period of time</span>

<span class="sd">        The outer loop that progresses the model over time by calling</span>
<span class="sd">        :py:meth:`~dt_solve` sequentially until ``end_time`` is reached.</span>
<span class="sd">        Each sequential call to :py:meth:`~dt_solve` will produce a new</span>
<span class="sd">        solved object that holds the current model states at the specific time.</span>
<span class="sd">        This data will be saved to :py:attr:`~solve_data`. The total time that</span>
<span class="sd">        it takes for this method to converge to a solution at ``end_time`` is</span>
<span class="sd">        saved in :py:attr:`~runtime`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dt : `int` or `float`</span>
<span class="sd">            Initial time step.</span>
<span class="sd">        dt_min : `int` or `float`, default is 1e-5</span>
<span class="sd">            Minimum time step size for which will be solved.</span>
<span class="sd">        dt_max : `int` or `float`, default is 0.5</span>
<span class="sd">            Maximum time step size for which will be solved.</span>
<span class="sd">        end_time : `int` or `float`, default is 1</span>
<span class="sd">            Total period of time for which will be solved.</span>
<span class="sd">        maxiter : `int`, default is 500</span>
<span class="sd">            Maximum number of iterations in which the system should</span>
<span class="sd">            converge to a solution.</span>
<span class="sd">        dtitlow : `float`, default is 1.5, :math:`&gt;1`</span>
<span class="sd">            Multiplier for increasing ``dt`` for the next time step.</span>
<span class="sd">        dtithigh : `float`, default is 0.5, :math:`\\langle 0,1 \\rangle`</span>
<span class="sd">            Multiplier for decreasing ``dt`` for the next time step.</span>
<span class="sd">        itermin : `int`, default is 5, :math:`&gt;2`</span>
<span class="sd">            Maximum number of iterations at which the time step ``dt``</span>
<span class="sd">            will be multiplied with its increasing multiplier ``dtitlow``</span>
<span class="sd">            for the next time step.</span>
<span class="sd">        itermax : `int`, default is 10, :math:`&gt;3`</span>
<span class="sd">            Minimum number of iterations at which the time step ``dt``</span>
<span class="sd">            will be multiplied with its decreasing multiplier ``dtithigh``</span>
<span class="sd">            for the next time step.</span>

<span class="sd">            .. warning::</span>
<span class="sd">                ``itermin`` &lt; ``itermin``. See the notes below for a</span>
<span class="sd">                precise description of the variable time step selection</span>
<span class="sd">                procedure.</span>

<span class="sd">        threshold : `float`, default is 1e-3</span>
<span class="sd">            Threshold for conversion, the system has converged when the</span>
<span class="sd">            definition below is satisfied:</span>

<span class="sd">            .. math::</span>
<span class="sd">                max(abs(s_{t-1}-s_{t})) &lt; max(abs(threshold * s_{t}))</span>

<span class="sd">        verbosity : `bool`, default is True</span>
<span class="sd">            Be descriptive about the solve process.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        .. note::</span>
<span class="sd">            This method may also be used for stationary systems in which no</span>
<span class="sd">            time step value is given. The default value for ``dt`` can be</span>
<span class="sd">            passed because of the method being independent from this argument</span>
<span class="sd">            in such a case.</span>

<span class="sd">        **Variable time step selection**</span>

<span class="sd">        The number of iterations, Niter, returned by :py:meth:`~dt_solve` will</span>
<span class="sd">        decide how the time step ``dt`` will be altered for the next call to</span>
<span class="sd">        :py:meth:`~dt_solve`. See the description below:</span>

<span class="sd">        1.  If Niter &gt; ``maxiter``, then ``dt`` * ``dtithigh``.</span>
<span class="sd">        2.  If Niter &lt; ``maxiter``, then check for the following:</span>

<span class="sd">                A.  If Niter &lt;= ``itermin``, then ``dt`` * ``dtitlow``.</span>
<span class="sd">                B.  If Niter &gt;= ``itermax``, then ``dt`` * ``dtithigh``.</span>
<span class="sd">                C.  If ``itermin`` &lt; Niter &lt; ``itermax``, then ``dt``.</span>

<span class="sd">        Note that ``dt`` cannot become smaller than ``dt_min`` or larger</span>
<span class="sd">        than ``dt_max``.</span>

<span class="sd">            .. warning::</span>
<span class="sd">                The size of the last time step is not determined by this</span>
<span class="sd">                procedure but will be calculated as difference between the</span>
<span class="sd">                current time and the ``end_time`` so the model will</span>
<span class="sd">                have its last solution on its ``end_time`` exactly.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from waterflow.flow1d.flowFE1d import Flow1DFE</span>
<span class="sd">        &gt;&gt;&gt; from waterflow.utility import conductivityfunctions as condf</span>
<span class="sd">        &gt;&gt;&gt; from waterflow.utility import fluxfunctions as fluxf</span>
<span class="sd">        &gt;&gt;&gt; from waterflow.utility.helper import initializer</span>

<span class="sd">        Select soil 13, &#39;loam&#39;, from De Staringreeks :cite:`Wosten2001`</span>
<span class="sd">        and prepare the conductivity function and theta-h relation with the</span>
<span class="sd">        soil parameters. These functions are the arguments to the fluxfunction</span>
<span class="sd">        and the storage change function repectively.</span>

<span class="sd">        &gt;&gt;&gt; s, *_ = condf.soilselector([13])[0]</span>
<span class="sd">        &gt;&gt;&gt; theta_h = initializer(condf.VG_pressureh, theta_r=s.t_res,</span>
<span class="sd">        ...                       theta_s=s.t_sat, a=s.alpha, n=s.n)</span>
<span class="sd">        &gt;&gt;&gt; kfun = initializer(condf.VG_conductivity, ksat=s.ksat, a=s.alpha, n=s.n)</span>
<span class="sd">        &gt;&gt;&gt; storage_change = initializer(fluxf.storage_change, fun=theta_h)</span>

<span class="sd">        &gt;&gt;&gt; FE = Flow1DFE(&quot;Solve for a period of time&quot;)</span>
<span class="sd">        &gt;&gt;&gt; FE.set_systemfluxfunction(fluxf.richards_equation, kfun=kfun)</span>
<span class="sd">        &gt;&gt;&gt; FE.set_field1d(nodes=(-10, 0, 11))</span>
<span class="sd">        &gt;&gt;&gt; FE.add_dirichlet_BC(0.0, &#39;west&#39;)</span>
<span class="sd">        &gt;&gt;&gt; FE.add_neumann_BC(-0.3, &#39;east&#39;)</span>
<span class="sd">        &gt;&gt;&gt; FE.add_spatialflux(-0.001, &#39;Extraction&#39;)</span>
<span class="sd">        &gt;&gt;&gt; FE.solve(verbosity=False)</span>
<span class="sd">        &gt;&gt;&gt; FE.solve_data.keys()</span>
<span class="sd">        dict_keys([&#39;solved_objects&#39;, &#39;time&#39;, &#39;dt&#39;, &#39;iter&#39;])</span>
<span class="sd">        &gt;&gt;&gt; # Solving the stationary system will call dt_solve only once. The</span>
<span class="sd">        &gt;&gt;&gt; # result is the initial object and the solved one.</span>
<span class="sd">        &gt;&gt;&gt; FE.solve_data[&#39;solved_objects&#39;]</span>
<span class="sd">        [Flow1DFE(Solve for a period of time), Flow1DFE(Solve for a period of time)]</span>

<span class="sd">        &gt;&gt;&gt; # Make the system transient</span>
<span class="sd">        &gt;&gt;&gt; FE.add_spatialflux(storage_change)</span>
<span class="sd">        &gt;&gt;&gt; # Change the boundary to drive a change in the currently</span>
<span class="sd">        &gt;&gt;&gt; # stationary solution.</span>
<span class="sd">        &gt;&gt;&gt; FE.add_neumann_BC(-0.4, &#39;east&#39;)</span>
<span class="sd">        &gt;&gt;&gt; FE.solve(verbosity=False, end_time=0.1)</span>
<span class="sd">        &gt;&gt;&gt; # This will now return a sequence of solved objects at specific times.</span>
<span class="sd">        &gt;&gt;&gt; FE.solve_data[&#39;solved_objects&#39;]</span>
<span class="sd">        [Flow1DFE(Solve for a period of time), Flow1DFE(Solve for a period of time), Flow1DFE(Solve for a period of time), Flow1DFE(Solve for a period of time), Flow1DFE(Solve for a period of time), Flow1DFE(Solve for a period of time), Flow1DFE(Solve for a period of time), Flow1DFE(Solve for a period of time), Flow1DFE(Solve for a period of time), Flow1DFE(Solve for a period of time), Flow1DFE(Solve for a period of time)]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">solved_objs</span> <span class="o">=</span> <span class="p">[</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span>
        <span class="n">time_data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dt_data</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">iter_data</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>

        <span class="n">time</span> <span class="o">=</span> <span class="n">dt</span>

        <span class="n">t0</span> <span class="o">=</span> <span class="n">Time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">time</span> <span class="o">&lt;=</span> <span class="n">end_time</span><span class="p">:</span>
            <span class="c1"># solve for given dt</span>
            <span class="n">iters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt_solve</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">maxiter</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>

            <span class="c1"># catch cases where maxiter is reached</span>
            <span class="k">if</span> <span class="n">iters</span> <span class="o">&gt;</span> <span class="n">maxiter</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dt</span> <span class="o">==</span> <span class="n">dt_min</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Maxiter </span><span class="si">{iters}</span><span class="s1"> at dt_min </span><span class="si">{dt_min}</span><span class="s1"> reached&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">isconverged</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Maxiter </span><span class="si">{iters}</span><span class="s1"> reached, dt </span><span class="si">{dt}</span><span class="s1"> is lowered...&#39;</span><span class="p">)</span>
                    <span class="n">dt</span> <span class="o">*=</span> <span class="n">dtithigh</span>
                    <span class="k">if</span> <span class="n">dt</span> <span class="o">&lt;</span> <span class="n">dt_min</span><span class="p">:</span>
                        <span class="n">dt</span> <span class="o">=</span> <span class="n">dt_min</span>
                    <span class="c1"># revert back to previous model state</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="n">solved_objs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">states</span>
                    <span class="k">continue</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">isconverged</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">verbosity</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sspatflux</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;storage_change&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;Converged at time=</span><span class="si">{}</span><span class="s1"> for dt=</span><span class="si">{}</span><span class="s1"> with </span><span class="si">{}</span><span class="s1"> iterations&#39;</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">iters</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Converged at </span><span class="si">{}</span><span class="s1"> iterations&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iters</span><span class="p">))</span>

            <span class="c1"># break out of loop when system is stationary</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sspatflux</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;storage_change&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">solved_objs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
                <span class="n">time_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
                <span class="n">dt_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
                <span class="n">iter_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iters</span><span class="p">)</span>
                <span class="k">break</span>

            <span class="c1"># build data record</span>
            <span class="n">solved_objs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="n">time_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
            <span class="n">dt_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
            <span class="n">iter_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iters</span><span class="p">)</span>

            <span class="c1"># adapt dt as function of iterations of previous step</span>
            <span class="k">if</span> <span class="n">iters</span> <span class="o">&lt;=</span> <span class="n">itermin</span><span class="p">:</span>
                <span class="n">dt</span> <span class="o">*=</span> <span class="n">dtitlow</span>
                <span class="k">if</span> <span class="n">dt</span> <span class="o">&gt;</span> <span class="n">dt_max</span><span class="p">:</span>
                    <span class="n">dt</span> <span class="o">=</span> <span class="n">dt_max</span>
            <span class="k">elif</span> <span class="n">iters</span> <span class="o">&gt;=</span> <span class="n">itermax</span><span class="p">:</span>
                <span class="n">dt</span> <span class="o">*=</span> <span class="n">dtithigh</span>
                <span class="k">if</span> <span class="n">dt</span> <span class="o">&lt;</span> <span class="n">dt_min</span><span class="p">:</span>
                    <span class="n">dt</span> <span class="o">=</span> <span class="n">dt_min</span>

            <span class="c1"># last time step calculated should be end_time exactly</span>
            <span class="n">remaining_time</span> <span class="o">=</span> <span class="n">end_time</span> <span class="o">-</span> <span class="n">time</span>
            <span class="k">if</span> <span class="n">remaining_time</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">remaining_time</span> <span class="o">&lt;</span> <span class="n">dt</span><span class="p">:</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="n">remaining_time</span>

            <span class="c1"># increment time</span>
            <span class="n">time</span> <span class="o">+=</span> <span class="n">dt</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">Time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span>

        <span class="c1"># attach all solve data to last created object</span>
        <span class="n">solve_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">solve_data</span><span class="p">[</span><span class="s1">&#39;solved_objects&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">solved_objs</span>
        <span class="n">solve_data</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time_data</span>
        <span class="n">solve_data</span><span class="p">[</span><span class="s1">&#39;dt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dt_data</span>
        <span class="n">solve_data</span><span class="p">[</span><span class="s1">&#39;iter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">iter_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solve_data</span> <span class="o">=</span> <span class="n">solve_data</span></div>

<div class="viewcode-block" id="Flow1DFE.calcbalance"><a class="viewcode-back" href="../../../waterflow.flow1d.html#waterflow.flow1d.flowFE1d.Flow1DFE.calcbalance">[docs]</a>    <span class="k">def</span> <span class="nf">calcbalance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">print_</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculate the water balance for the system</span>

<span class="sd">        The water balance values are calculated at every position</span>
<span class="sd">        in the domain and will be saved to :py:attr:`~df_balance`.</span>
<span class="sd">        The summary of the water balance, which is the sum of all</span>
<span class="sd">        relevant columns, is saved in :py:attr:`~df_balance_summary`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        print_ : `bool`, default is ``False``</span>
<span class="sd">            Print :py:attr:`~df_balance_summary` to the console.</span>
<span class="sd">        invert : `bool`, default is ``True``</span>
<span class="sd">            Mirror :py:attr:`~df_balance` w.r.t. the x-axis.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The external fluxes, :math:`F_{external}`, are the sum of all point</span>
<span class="sd">        and spatial fluxes.</span>

<span class="sd">        .. math::</span>
<span class="sd">            F_{external} = \\sum_{j=1}^{n} S_{j} + \\sum_{k=1}^{m} P_{k}</span>

<span class="sd">        The calculation of the pointflux, :math:`P_{k}`, depends on its</span>
<span class="sd">        nature. If the pointflux depends on position only, the accumulation is</span>
<span class="sd">        straightforward. When the pointflux is dependent on the state of the</span>
<span class="sd">        the system, the distribution towards the surrounding nodes needs to be</span>
<span class="sd">        calculated before values can be accumulated. The distribution to the</span>
<span class="sd">        nearest nodes is calculated as follows:</span>

<span class="sd">        .. math::</span>
<span class="sd">            node_{i} = P_{k}(s) * lfac</span>

<span class="sd">        .. math::</span>
<span class="sd">            node_{i+1} = P_{k}(s) * rfac</span>

<span class="sd">        where :math:`s` equals the state at the position of the pointflux</span>
<span class="sd">        which is calculated by linear interpolation between the nearest nodes.</span>
<span class="sd">        The calculation of the fractions, that distribute the flux,</span>
<span class="sd">        :math:`rfac` and :math:`lfac` are described in</span>
<span class="sd">        :py:meth:`~add_pointflux`.</span>

<span class="sd">        For the calculation of the spatial flux, :math:`S_{j}`, a similar</span>
<span class="sd">        distinction exists. If the spatial flux is not dependend on state,</span>
<span class="sd">        straightforward addition takes place. When there is a state</span>
<span class="sd">        dependency, distributions towards the nodes is calculated as</span>
<span class="sd">        described in :py:meth:`~_statedep_forcing`. This calculation accounts</span>
<span class="sd">        for the selected :py:attr:`~gauss_degree` and the state argument</span>
<span class="sd">        :math:`s` is linearly interpolated between the neareast nodes.</span>

<span class="sd">        The total forcing in the water balance is the sum of the internal</span>
<span class="sd">        forcing as described in :py:meth:`~_internal_forcing` and the external</span>
<span class="sd">        forcing.</span>

<span class="sd">        .. math::</span>
<span class="sd">            F_{total} = F_{internal} + F_{external}</span>

<span class="sd">        The top and bottom values in :math:`F_{total}` are corrected</span>
<span class="sd">        for the flow over the boundaries. The flow over the boundaries is</span>
<span class="sd">        calculated as the difference of :math:`F_{total}` -</span>
<span class="sd">        :math:`\\Delta s` at those boundary nodes.</span>

<span class="sd">        The net flux is calculated as follows:</span>

<span class="sd">        .. math::</span>
<span class="sd">            F_{net} = F_{total} - \\Delta s</span>

<span class="sd">        Where :math:`\\Delta s` represents the storage change between</span>
<span class="sd">        iterations at every node in the domain.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Although the storage change :math:`\\Delta s` is entered into the</span>
<span class="sd">            model as an external flux, in the calculation of the water balance</span>
<span class="sd">            this term is handled as a separate flux which is not included in</span>
<span class="sd">            the :math:`F_{external}` term.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from waterflow.flow1d.flowFE1d import Flow1DFE</span>
<span class="sd">        &gt;&gt;&gt; from waterflow.utility import conductivityfunctions as condf</span>
<span class="sd">        &gt;&gt;&gt; from waterflow.utility import fluxfunctions as fluxf</span>
<span class="sd">        &gt;&gt;&gt; from waterflow.utility.helper import initializer</span>

<span class="sd">        Select soil 13, &#39;loam&#39;, from De Staringreeks :cite:`Wosten2001`</span>
<span class="sd">        and prepare the conductivity function and theta-h relation with the</span>
<span class="sd">        soil parameters. These functions are the arguments to the fluxfunction</span>
<span class="sd">        and the storage change function repectively.</span>

<span class="sd">        &gt;&gt;&gt; s, *_ = condf.soilselector([13])[0]</span>
<span class="sd">        &gt;&gt;&gt; theta_h = initializer(condf.VG_pressureh, theta_r=s.t_res,</span>
<span class="sd">        ...                       theta_s=s.t_sat, a=s.alpha, n=s.n)</span>
<span class="sd">        &gt;&gt;&gt; kfun = initializer(condf.VG_conductivity, ksat=s.ksat, a=s.alpha, n=s.n)</span>
<span class="sd">        &gt;&gt;&gt; storage_change = initializer(fluxf.storage_change, fun=theta_h)</span>

<span class="sd">        &gt;&gt;&gt; FE = Flow1DFE(&quot;Calculate water balance&quot;)</span>
<span class="sd">        &gt;&gt;&gt; FE.set_systemfluxfunction(fluxf.richards_equation, kfun=kfun)</span>
<span class="sd">        &gt;&gt;&gt; FE.set_field1d(nodes=(-10, 0, 11))</span>
<span class="sd">        &gt;&gt;&gt; FE.add_dirichlet_BC(0.0, &#39;west&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # Constant boundary flow of 0.3 cm/d out of the system</span>
<span class="sd">        &gt;&gt;&gt; FE.add_neumann_BC(-0.3, &#39;east&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # theta_h function needs to be added manually to be included in the water balance</span>
<span class="sd">        &gt;&gt;&gt; FE.tfun = theta_h</span>
<span class="sd">        &gt;&gt;&gt; # Extraction of 0.001 cm/d over the complete domain</span>
<span class="sd">        &gt;&gt;&gt; FE.add_spatialflux(-0.001, &#39;extraction&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # Add storage change function</span>
<span class="sd">        &gt;&gt;&gt; FE.add_spatialflux(storage_change)</span>
<span class="sd">        &gt;&gt;&gt; # Solve the system for one time step (dt=0.01 d)</span>
<span class="sd">        &gt;&gt;&gt; iters = FE.dt_solve(dt=0.01)</span>
<span class="sd">        &gt;&gt;&gt; FE.calcbalance()</span>
<span class="sd">        &gt;&gt;&gt; FE.df_balance</span>
<span class="sd">            nodes  spat-extraction  storage_change  internal  all-spatial  all-points  all-external           net    fluxes</span>
<span class="sd">        0     0.0          -0.0005        0.144730 -0.144730      -0.0005         0.0       -0.0005  0.000000e+00  0.155770</span>
<span class="sd">        1    -1.0          -0.0010        0.266555 -0.266555      -0.0010         0.0       -0.0010 -4.663325e-12 -0.109784</span>
<span class="sd">        2    -2.0          -0.0010        0.222706 -0.222706      -0.0010         0.0       -0.0010 -2.797818e-12 -0.331490</span>
<span class="sd">        3    -3.0          -0.0010        0.182558 -0.182558      -0.0010         0.0       -0.0010 -6.783463e-14 -0.513048</span>
<span class="sd">        4    -4.0          -0.0010        0.145754 -0.145754      -0.0010         0.0       -0.0010  1.635247e-12 -0.657801</span>
<span class="sd">        5    -5.0          -0.0010        0.112096 -0.112096      -0.0010         0.0       -0.0010  1.979528e-12 -0.768897</span>
<span class="sd">        6    -6.0          -0.0010        0.081552 -0.081552      -0.0010         0.0       -0.0010  1.637579e-12 -0.849449</span>
<span class="sd">        7    -7.0          -0.0010        0.054287 -0.054287      -0.0010         0.0       -0.0010  1.292744e-12 -0.902736</span>
<span class="sd">        8    -8.0          -0.0010        0.030765 -0.030765      -0.0010         0.0       -0.0010  1.127098e-12 -0.932501</span>
<span class="sd">        9    -9.0          -0.0010        0.012078 -0.012078      -0.0010         0.0       -0.0010  1.573075e-12 -0.943580</span>
<span class="sd">        10  -10.0          -0.0005        0.002068 -0.002068      -0.0005         0.0       -0.0005  0.000000e+00 -0.945148</span>
<span class="sd">        &gt;&gt;&gt; FE.df_balance_summary</span>
<span class="sd">        spat-extraction   -1.000000e-02</span>
<span class="sd">        storage_change     1.255148e+00</span>
<span class="sd">        internal          -1.255148e+00</span>
<span class="sd">        all-spatial       -1.000000e-02</span>
<span class="sd">        all-points         0.000000e+00</span>
<span class="sd">        all-external      -1.000000e-02</span>
<span class="sd">        net                1.716294e-12</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># internal fluxes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_internal_forcing</span><span class="p">(</span><span class="n">calcbal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_internal_forcing</span><span class="p">(</span><span class="n">calcflux</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">internalfluxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_forcing</span><span class="p">[</span><span class="s1">&#39;internal_forcing&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># add all point fluxes</span>
        <span class="n">pnt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">))</span>
        <span class="n">pointfluxes</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">pointflux</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">Spointflux</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">pointfluxes</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># if state dependent, calculate new forcing for new states</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Spointflux</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">))]</span>
                <span class="p">(</span><span class="n">Sfunc</span><span class="p">,</span> <span class="p">(</span><span class="n">idx_l</span><span class="p">,</span> <span class="n">idx_r</span><span class="p">,</span> <span class="n">lfac</span><span class="p">,</span> <span class="n">rfac</span><span class="p">)),</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Spointflux</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="c1"># calculate state at position by linear interpolation</span>
                <span class="n">dstates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">idx_r</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">idx_l</span><span class="p">]</span>
                <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">idx_l</span><span class="p">]</span> <span class="o">+</span> <span class="n">rfac</span> <span class="o">*</span> <span class="n">dstates</span>
                <span class="c1"># calculate function value and distribute fluxes accordingly</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">Sfunc</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
                <span class="n">f</span><span class="p">[</span><span class="n">idx_l</span><span class="p">]</span> <span class="o">+=</span> <span class="n">value</span> <span class="o">*</span> <span class="n">lfac</span>
                <span class="n">f</span><span class="p">[</span><span class="n">idx_r</span><span class="p">]</span> <span class="o">+=</span> <span class="n">value</span> <span class="o">*</span> <span class="n">rfac</span>
                <span class="n">pnt</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="c1"># if constant/position dependent then no need for a new calculation</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pnt</span> <span class="o">+=</span> <span class="n">pointfluxes</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">data</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;pnt-&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">):</span> <span class="n">pointfluxes</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]})</span>

        <span class="c1"># add all spatial fluxes</span>
        <span class="n">spat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">))</span>
        <span class="n">spatialfluxes</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">spatflux</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">Sspatflux</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">spatialfluxes</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># if state dependent, calculate new forcing for new states</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sspatflux</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">pos</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussquad</span>
                <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">))]</span>
                <span class="n">Sfunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sspatflux</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seg_lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">)):</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xintegration</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
                        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="c1"># linearly interpolate the state value</span>
                        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">ds</span> <span class="o">/</span> <span class="n">L</span><span class="p">)</span>
                        <span class="c1"># assign to nearby nodes according to scheme</span>
                        <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Sfunc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="o">-</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[</span><span class="o">-</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">L</span>
                        <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Sfunc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">L</span>
                <span class="n">spat</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="c1"># if constant/position dependent then no need for a new calculation</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">spat</span> <span class="o">+=</span> <span class="n">spatialfluxes</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">data</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;spat-&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">):</span> <span class="n">spatialfluxes</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]})</span>

        <span class="c1"># storage between iterations, if exists</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">storage_change</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;spat-storage_change&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">storage_change</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">))</span>

        <span class="c1"># remove storage change from external spatial forcings</span>
        <span class="n">spat</span> <span class="o">=</span> <span class="n">spat</span> <span class="o">-</span> <span class="n">storage_change</span>

        <span class="c1"># internal balance</span>
        <span class="n">internalfluxes</span> <span class="o">=</span> <span class="n">internalfluxes</span> <span class="o">+</span> <span class="n">pnt</span> <span class="o">+</span> <span class="n">spat</span>

        <span class="c1"># boundaries</span>
        <span class="n">lbound</span> <span class="o">=</span> <span class="n">internalfluxes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">storage_change</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">rbound</span> <span class="o">=</span> <span class="n">internalfluxes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">storage_change</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># correct for boundary fluxes</span>
        <span class="n">internalfluxes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">lbound</span>
        <span class="n">internalfluxes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">rbound</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">lbound</span>

        <span class="c1"># net flow</span>
        <span class="n">net</span> <span class="o">=</span> <span class="n">internalfluxes</span> <span class="o">+</span> <span class="n">storage_change</span>

        <span class="c1"># dump waterbalance &amp; summary to dataframe</span>
        <span class="n">data</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;storage_change&#39;</span><span class="p">:</span> <span class="n">storage_change</span><span class="p">,</span>
                     <span class="s1">&#39;internal&#39;</span><span class="p">:</span> <span class="n">internalfluxes</span><span class="p">,</span> <span class="s1">&#39;all-spatial&#39;</span><span class="p">:</span> <span class="n">spat</span><span class="p">,</span>
                     <span class="s1">&#39;all-points&#39;</span><span class="p">:</span> <span class="n">pnt</span><span class="p">,</span> <span class="s1">&#39;all-external&#39;</span><span class="p">:</span> <span class="n">pnt</span> <span class="o">+</span> <span class="n">spat</span><span class="p">,</span>
                     <span class="s1">&#39;net&#39;</span><span class="p">:</span> <span class="n">net</span><span class="p">,</span> <span class="s1">&#39;fluxes&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span><span class="p">})</span>

        <span class="n">df_balance</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">df_balance</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;nodes&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">invert</span><span class="p">:</span>
            <span class="n">df_balance</span> <span class="o">=</span> <span class="n">df_balance</span><span class="o">.</span><span class="n">iloc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">df_balance</span> <span class="o">=</span> <span class="n">df_balance</span>
        <span class="n">df_balance_summary</span> <span class="o">=</span> <span class="n">df_balance</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s1">&#39;nodes&#39;</span><span class="p">,</span> <span class="s1">&#39;fluxes&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_balance_summary</span> <span class="o">=</span> <span class="n">df_balance_summary</span>

        <span class="k">if</span> <span class="n">print_</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df_balance_summary</span><span class="p">)</span></div>

<div class="viewcode-block" id="Flow1DFE.dataframeify"><a class="viewcode-back" href="../../../waterflow.flow1d.html#waterflow.flow1d.flowFE1d.Flow1DFE.dataframeify">[docs]</a>    <span class="k">def</span> <span class="nf">dataframeify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">invert</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Write internal model values to a dataframe</span>

<span class="sd">        Save the static model results to :py:attr:`~df_states`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        invert : `bool`</span>
<span class="sd">            Mirror :py:attr:`~df_states` w.r.t. the x-axis.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        At least, lengths, nodes, states and the internal forcing are written</span>
<span class="sd">        to the dataframe.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from waterflow.flow1d.flowFE1d import Flow1DFE</span>
<span class="sd">        &gt;&gt;&gt; from waterflow.utility import conductivityfunctions as condf</span>
<span class="sd">        &gt;&gt;&gt; from waterflow.utility import fluxfunctions as fluxf</span>
<span class="sd">        &gt;&gt;&gt; from waterflow.utility.helper import initializer</span>

<span class="sd">        Select soil 13, &#39;loam&#39;, from De Staringreeks :cite:`Wosten2001`</span>
<span class="sd">        and prepare the conductivity function and theta-h relation with the</span>
<span class="sd">        soil parameters. These functions are the arguments to the fluxfunction</span>
<span class="sd">        and the storage change function repectively. Note that the theta-h</span>
<span class="sd">        relation needs to be added to the model explicitly.</span>

<span class="sd">        &gt;&gt;&gt; s, *_ = condf.soilselector([13])[0]</span>
<span class="sd">        &gt;&gt;&gt; theta_h = initializer(condf.VG_pressureh, theta_r=s.t_res,</span>
<span class="sd">        ...                       theta_s=s.t_sat, a=s.alpha, n=s.n)</span>
<span class="sd">        &gt;&gt;&gt; kfun = initializer(condf.VG_conductivity, ksat=s.ksat, a=s.alpha, n=s.n)</span>
<span class="sd">        &gt;&gt;&gt; storage_change = initializer(fluxf.storage_change, fun=theta_h)</span>

<span class="sd">        &gt;&gt;&gt; FE = Flow1DFE(&quot;static df_states dataframe&quot;)</span>
<span class="sd">        &gt;&gt;&gt; FE.set_systemfluxfunction(fluxf.richards_equation, kfun=kfun)</span>
<span class="sd">        &gt;&gt;&gt; FE.set_field1d(nodes=(-10, 0, 11))</span>
<span class="sd">        &gt;&gt;&gt; FE.add_dirichlet_BC(0.0, &#39;west&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # Constant boundary flow of 0.3 cm/d out of the system</span>
<span class="sd">        &gt;&gt;&gt; FE.add_neumann_BC(-0.3, &#39;east&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # theta_h add manually to be included in the dataframe</span>
<span class="sd">        &gt;&gt;&gt; FE.tfun = theta_h</span>
<span class="sd">        &gt;&gt;&gt; # Add storage change function</span>
<span class="sd">        &gt;&gt;&gt; FE.add_spatialflux(storage_change)</span>
<span class="sd">        &gt;&gt;&gt; # Solve the system for one time step (dt=0.01 d)</span>
<span class="sd">        &gt;&gt;&gt; iters = FE.dt_solve(dt=0.01)</span>
<span class="sd">        &gt;&gt;&gt; FE.dataframeify(invert=True)</span>
<span class="sd">        &gt;&gt;&gt; FE.df_states</span>
<span class="sd">            lengths  nodes    states  moisture  conductivities  storage_change  internal_forcing</span>
<span class="sd">        0       0.5    0.0 -9.304032  0.416865        5.936014        0.144618          0.155382</span>
<span class="sd">        1       1.0   -1.0 -8.278454  0.417344        6.220225        0.266340         -0.266340</span>
<span class="sd">        2       1.0   -2.0 -7.295883  0.417781        6.519720        0.222509         -0.222509</span>
<span class="sd">        3       1.0   -3.0 -6.345835  0.418182        6.840203        0.182383         -0.182383</span>
<span class="sd">        4       1.0   -4.0 -5.419426  0.418549        7.189191        0.145605         -0.145605</span>
<span class="sd">        5       1.0   -5.0 -4.509093  0.418885        7.577188        0.111975         -0.111975</span>
<span class="sd">        6       1.0   -6.0 -3.608378  0.419190        8.020009        0.081460         -0.081460</span>
<span class="sd">        7       1.0   -7.0 -2.711757  0.419462        8.544065        0.054224         -0.054224</span>
<span class="sd">        8       1.0   -8.0 -1.814469  0.419698        9.201041        0.030729         -0.030729</span>
<span class="sd">        9       1.0   -9.0 -0.912220  0.419888       10.126956        0.012064         -0.012064</span>
<span class="sd">        10      0.5  -10.0  0.000000  0.420000       12.980000        0.002066          0.951906</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calc_theta_k</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_solve_initial_object</span><span class="p">()</span>

        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;lengths&#39;</span><span class="p">,</span> <span class="s1">&#39;nodes&#39;</span><span class="p">,</span> <span class="s1">&#39;states&#39;</span><span class="p">,</span> <span class="s1">&#39;moisture&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;conductivities&#39;</span><span class="p">,</span> <span class="s1">&#39;pointflux&#39;</span><span class="p">,</span> <span class="s1">&#39;Spointflux&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;spatflux&#39;</span><span class="p">,</span> <span class="s1">&#39;Sspatflux&#39;</span><span class="p">,</span> <span class="s1">&#39;internal_forcing&#39;</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">columns</span><span class="p">):</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">data</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">elif</span> <span class="mi">3</span> <span class="o">&lt;=</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">invert</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_states</span> <span class="o">=</span> <span class="n">df</span></div>

<div class="viewcode-block" id="Flow1DFE.transient_dataframeify"><a class="viewcode-back" href="../../../waterflow.flow1d.html#waterflow.flow1d.flowFE1d.Flow1DFE.transient_dataframeify">[docs]</a>    <span class="k">def</span> <span class="nf">transient_dataframeify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">print_times</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include_maxima</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Combine the static dataframes to a transient collection</span>

<span class="sd">        This method will build the following dataframes:</span>
<span class="sd">        :py:meth:`~dft_solved_times`, :py:attr:`dft_states`,</span>
<span class="sd">        :py:attr:`dft_balance`, :py:attr:`dft_balance_summary`.</span>

<span class="sd">        Generation of :py:attr:`dft_print_times` and :py:attr:`dft_nodes`</span>
<span class="sd">        depends on the ``print_times`` and ``nodes`` arguments.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        print_times : `int`, `list` or `numpy.ndarray`, default is None</span>
<span class="sd">            Number of linearly spaced print times, or sequence of specific</span>
<span class="sd">            print times.</span>
<span class="sd">        include_maxima : `bool`, default is ``True``</span>
<span class="sd">            Include both endpoints in the dataframe.</span>
<span class="sd">        nodes : `list` or `numpy.ndarray`, default is None</span>
<span class="sd">            Positional values of the nodes that will be tracked over time.</span>
<span class="sd">        invert : `bool`, default is ``True``</span>
<span class="sd">            Mirror the built dataframes w.r.t. the x-axis.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The default behaviour is to generate the dataframes for the times at</span>
<span class="sd">        which the model has been solved. These times are selected by the</span>
<span class="sd">        :py:meth:`~solve` method and saved in :py:attr:`~dft_solved_times`.</span>
<span class="sd">        When ``print_times != None``, the collection of the static dataframes</span>
<span class="sd">        will be built at the new print times. This requires the model to</span>
<span class="sd">        calculate new model objects. The calculations are done from the nearest</span>
<span class="sd">        known object that was solved for in terms of time</span>
<span class="sd">        (:py:attr:`~dft_solved_times`) and will be saved in</span>
<span class="sd">        :py:attr:`~dft_print_times`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from waterflow.flow1d.flowFE1d import Flow1DFE</span>
<span class="sd">        &gt;&gt;&gt; from waterflow.utility import conductivityfunctions as condf</span>
<span class="sd">        &gt;&gt;&gt; from waterflow.utility import fluxfunctions as fluxf</span>
<span class="sd">        &gt;&gt;&gt; from waterflow.utility.helper import initializer</span>

<span class="sd">        Select soil 13, &#39;loam&#39;, from De Staringreeks :cite:`Wosten2001`</span>
<span class="sd">        and prepare the conductivity function and theta-h relation with the</span>
<span class="sd">        soil parameters. These functions are the arguments to the fluxfunction</span>
<span class="sd">        and the storage change function repectively.</span>

<span class="sd">        &gt;&gt;&gt; s, *_ = condf.soilselector([13])[0]</span>
<span class="sd">        &gt;&gt;&gt; theta_h = initializer(condf.VG_pressureh, theta_r=s.t_res,</span>
<span class="sd">        ...                       theta_s=s.t_sat, a=s.alpha, n=s.n)</span>
<span class="sd">        &gt;&gt;&gt; kfun = initializer(condf.VG_conductivity, ksat=s.ksat, a=s.alpha, n=s.n)</span>
<span class="sd">        &gt;&gt;&gt; storage_change = initializer(fluxf.storage_change, fun=theta_h)</span>

<span class="sd">        &gt;&gt;&gt; FE = Flow1DFE(&quot;All transient dataframes&quot;)</span>
<span class="sd">        &gt;&gt;&gt; FE.set_systemfluxfunction(fluxf.richards_equation, kfun=kfun)</span>
<span class="sd">        &gt;&gt;&gt; FE.set_field1d(nodes=(-100, 0, 11))</span>
<span class="sd">        &gt;&gt;&gt; FE.add_dirichlet_BC(0.0, &#39;west&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # Constant boundary flow of 0.3 cm/d out of the system</span>
<span class="sd">        &gt;&gt;&gt; FE.add_neumann_BC(-0.3, &#39;east&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # theta_h add manually to be included in the dataframe</span>
<span class="sd">        &gt;&gt;&gt; FE.tfun = theta_h</span>
<span class="sd">        &gt;&gt;&gt; # Extraction of 0.001 cm/d over the complete domain</span>
<span class="sd">        &gt;&gt;&gt; FE.add_spatialflux(-0.001, &#39;extraction&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # Add storage change function</span>
<span class="sd">        &gt;&gt;&gt; FE.add_spatialflux(storage_change)</span>
<span class="sd">        &gt;&gt;&gt; FE.solve(end_time=5, verbosity=False)</span>
<span class="sd">        &gt;&gt;&gt; FE.transient_dataframeify(nodes=[0, -2, -5, -8, -10])</span>
<span class="sd">        &gt;&gt;&gt; # returns None because it is empty</span>
<span class="sd">        &gt;&gt;&gt; FE.dft_print_times</span>

<span class="sd">        &gt;&gt;&gt; FE.dft_solved_times.head()</span>
<span class="sd">                               solved_objects     time       dt  iter</span>
<span class="sd">        0  Flow1DFE(All transient dataframes)  0.00000      NaN   NaN</span>
<span class="sd">        1  Flow1DFE(All transient dataframes)  0.00100  0.00100   7.0</span>
<span class="sd">        2  Flow1DFE(All transient dataframes)  0.00200  0.00100   3.0</span>
<span class="sd">        3  Flow1DFE(All transient dataframes)  0.00350  0.00150   3.0</span>
<span class="sd">        4  Flow1DFE(All transient dataframes)  0.00575  0.00225   3.0</span>

<span class="sd">        &gt;&gt;&gt; # access transient data from the top node</span>
<span class="sd">        &gt;&gt;&gt; FE.dft_nodes[0]</span>
<span class="sd">                time  lengths  nodes      states  moisture  conductivities  extraction  storage_change  internal_forcing</span>
<span class="sd">        0   0.000000      5.0    0.0    0.000000  0.420000       12.980000      -0.005        0.000000        -12.980000</span>
<span class="sd">        1   0.001000      5.0    0.0   -6.230996  0.418228        6.881334      -0.005        4.413886         -4.108886</span>
<span class="sd">        2   0.002000      5.0    0.0   -8.525052  0.417231        6.149441      -0.005        3.381237         -3.076237</span>
<span class="sd">        3   0.003500      5.0    0.0  -10.769689  0.416145        5.570882      -0.005        2.713307         -2.408307</span>
<span class="sd">        4   0.005750      5.0    0.0  -13.147704  0.414894        5.058867      -0.005        2.213596         -1.908596</span>
<span class="sd">        5   0.009125      5.0    0.0  -15.759044  0.413423        4.583379      -0.005        1.816135         -1.511135</span>
<span class="sd">        6   0.014188      5.0    0.0  -18.682582  0.411673        4.131618      -0.005        1.490460         -1.185460</span>
<span class="sd">        7   0.021781      5.0    0.0  -21.992779  0.409584        3.698174      -0.005        1.219763         -0.914763</span>
<span class="sd">        8   0.033172      5.0    0.0  -25.766774  0.407089        3.281456      -0.005        0.993457         -0.688457</span>
<span class="sd">        9   0.050258      5.0    0.0  -30.088421  0.404117        2.882094      -0.005        0.804074         -0.499074</span>
<span class="sd">        10  0.075887      5.0    0.0  -35.050660  0.400591        2.502107      -0.005        0.645821         -0.340821</span>
<span class="sd">        11  0.114330      5.0    0.0  -40.755672  0.396435        2.144426      -0.005        0.513876         -0.208876</span>
<span class="sd">        12  0.171995      5.0    0.0  -47.311047  0.391582        1.812568      -0.005        0.404104         -0.099104</span>
<span class="sd">        13  0.258493      5.0    0.0  -54.818914  0.385985        1.510322      -0.005        0.312974         -0.007974</span>
<span class="sd">        14  0.388239      5.0    0.0  -63.353249  0.379645        1.241351      -0.005        0.237546          0.067454</span>
<span class="sd">        15  0.582859      5.0    0.0  -72.918234  0.372640        1.008723      -0.005        0.175458          0.129542</span>
<span class="sd">        16  0.874788      5.0    0.0  -83.379449  0.365167        0.814411      -0.005        0.124874          0.180126</span>
<span class="sd">        17  1.312682      5.0    0.0  -94.367200  0.357578        0.658911      -0.005        0.084417          0.220583</span>
<span class="sd">        18  1.812682      5.0    0.0 -103.335192  0.351603        0.559141      -0.005        0.058055          0.246945</span>
<span class="sd">        19  2.312682      5.0    0.0 -109.947478  0.347330        0.497676      -0.005        0.041411          0.263589</span>
<span class="sd">        20  2.812682      5.0    0.0 -114.891068  0.344208        0.457272      -0.005        0.030168          0.274832</span>
<span class="sd">        21  3.312682      5.0    0.0 -118.614160  0.341899        0.429578      -0.005        0.022269          0.282730</span>
<span class="sd">        22  3.812682      5.0    0.0 -121.429531  0.340177        0.410046      -0.005        0.016582          0.288417</span>
<span class="sd">        23  4.312682      5.0    0.0 -123.563493  0.338885        0.395994      -0.005        0.012421          0.292579</span>
<span class="sd">        24  4.812682      5.0    0.0 -125.183260  0.337912        0.385736      -0.005        0.009343          0.295657</span>
<span class="sd">        25  5.000000      5.0    0.0 -125.727039  0.337587        0.382369      -0.005        0.008330          0.296670</span>

<span class="sd">        &gt;&gt;&gt; # Revert to initial model state</span>
<span class="sd">        &gt;&gt;&gt; FE.set_initial_states(0.0)</span>
<span class="sd">        &gt;&gt;&gt; FE.solve(end_time=5, verbosity=False)</span>
<span class="sd">        &gt;&gt;&gt; # 5 linearly spaced print times</span>
<span class="sd">        &gt;&gt;&gt; FE.transient_dataframeify(nodes=[0, -2, -5, -8, -10], print_times=5)</span>
<span class="sd">        &gt;&gt;&gt; FE.dft_nodes[0]</span>
<span class="sd">           time  lengths  nodes      states  moisture  conductivities  extraction  storage_change  internal_forcing</span>
<span class="sd">        0  0.00      5.0    0.0    0.000000  0.420000       12.980000      -0.005        0.008330          0.296670</span>
<span class="sd">        1  1.25      5.0    0.0  -93.203885  0.358368        0.673469      -0.005        0.088281          0.216719</span>
<span class="sd">        2  2.50      5.0    0.0 -112.163382  0.345923        0.479024      -0.005        0.036331          0.268668</span>
<span class="sd">        3  3.75      5.0    0.0 -121.156173  0.340343        0.411892      -0.005        0.017130          0.287870</span>
<span class="sd">        4  5.00      5.0    0.0 -125.727039  0.337587        0.382369      -0.005        0.008330          0.296670</span>

<span class="sd">        &gt;&gt;&gt; FE.dft_print_times</span>
<span class="sd">                               solved_objects  time</span>
<span class="sd">        0  Flow1DFE(All transient dataframes)  0.00</span>
<span class="sd">        1  Flow1DFE(All transient dataframes)  1.25</span>
<span class="sd">        2  Flow1DFE(All transient dataframes)  2.50</span>
<span class="sd">        3  Flow1DFE(All transient dataframes)  3.75</span>
<span class="sd">        4  Flow1DFE(All transient dataframes)  5.00</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># times at which the model has been solved</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dft_solved_times</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">solve_data</span><span class="p">)</span>

        <span class="c1"># solve model at specific print times</span>
        <span class="k">if</span> <span class="n">print_times</span><span class="p">:</span>
            <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve_data</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
            <span class="n">solved_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve_data</span><span class="p">[</span><span class="s1">&#39;solved_objects&#39;</span><span class="p">]</span>

            <span class="c1"># print_times can be a sequence or a scalar</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">print_times</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                <span class="n">pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">print_times</span><span class="p">)</span>
                <span class="n">pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">pt</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="n">st</span><span class="p">)))</span>
                <span class="n">pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">pt</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">st</span><span class="p">)))</span>
                <span class="k">if</span> <span class="n">include_maxima</span><span class="p">:</span>
                    <span class="n">pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">st</span><span class="p">))</span>
                    <span class="n">pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">st</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">st</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">st</span><span class="p">),</span> <span class="n">print_times</span><span class="p">)</span>
            <span class="n">pt</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>

            <span class="c1"># Find solved model that is nearest in terms of time</span>
            <span class="c1"># solve the model for the new time from here</span>
            <span class="n">new_obj</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">pt</span><span class="p">)):</span>
                <span class="c1"># print time already equals known state</span>
                <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">new_obj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">solved_obj</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="c1"># calculate model state at new time</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dts</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="n">st</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">obj</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">solved_obj</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">dt_solve</span><span class="p">(</span><span class="n">dts</span><span class="p">)</span>
                    <span class="n">new_obj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

            <span class="c1"># dump model states at print times to dataframe</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;solved_objects&#39;</span><span class="p">:</span> <span class="n">new_obj</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="n">pt</span><span class="p">}</span>
            <span class="n">dft_print_times</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dft_print_times</span> <span class="o">=</span> <span class="n">dft_print_times</span>

        <span class="c1"># if no specific print times remove dataframe</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dft_print_times</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># if available, use print times instead of solved_times</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dft_print_times</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">timedf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dft_print_times</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">timedf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dft_solved_times</span>

        <span class="c1"># build all dataframes</span>
        <span class="n">dft_states</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">dft_balance</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">dft_nodes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">dft_bal_sum</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">timedf</span><span class="o">.</span><span class="n">itertuples</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="n">obj</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">solved_objects</span><span class="p">,</span> <span class="n">row</span><span class="o">.</span><span class="n">time</span>

            <span class="c1"># states dataframe</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">dataframeify</span><span class="p">(</span><span class="n">invert</span><span class="o">=</span><span class="n">invert</span><span class="p">)</span>
            <span class="n">dft_states</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">t</span><span class="p">:</span> <span class="n">obj</span><span class="o">.</span><span class="n">df_states</span><span class="p">})</span>

            <span class="c1"># balance dataframes</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">calcbalance</span><span class="p">(</span><span class="n">invert</span><span class="o">=</span><span class="n">invert</span><span class="p">)</span>
            <span class="n">dft_balance</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">t</span><span class="p">:</span> <span class="n">obj</span><span class="o">.</span><span class="n">df_balance</span><span class="p">})</span>
            <span class="n">dft_bal_sum</span> <span class="o">=</span> <span class="n">dft_bal_sum</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">df_balance_summary</span><span class="p">,</span>
                                             <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># track specific nodes (if present)</span>
            <span class="k">if</span> <span class="n">nodes</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">dft_nodes</span><span class="p">:</span>
                    <span class="n">dft_nodes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">)</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">df_states</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
                    <span class="n">nrow</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dft_nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]):</span>
                        <span class="n">dft_nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">dft_nodes</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">nrow</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">dft_nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">nrow</span>

        <span class="c1"># nodes dataframe (if present)</span>
        <span class="k">if</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dft_nodes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>
                <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">timedf</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">timedf</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dft_nodes</span> <span class="o">=</span> <span class="n">d</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dft_states</span> <span class="o">=</span> <span class="n">dft_states</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dft_balance</span> <span class="o">=</span> <span class="n">dft_balance</span>
        <span class="n">dft_bal_sum</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">timedf</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">timedf</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dft_balance_summary</span> <span class="o">=</span> <span class="n">dft_bal_sum</span></div>

<div class="viewcode-block" id="Flow1DFE.save"><a class="viewcode-back" href="../../../waterflow.flow1d.html#waterflow.flow1d.flowFE1d.Flow1DFE.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">savepath</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dirname</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Save model data to disk</span>

<span class="sd">        The transient dataframes created with</span>
<span class="sd">        :py:meth:`~transient_dataframeify` and the model summary as created</span>
<span class="sd">        with :py:meth:`~summary` will be saved to disk by this method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        savepath: `str`, default is :py:attr:`~savepath`</span>
<span class="sd">            A base path to which runs will be saved.</span>
<span class="sd">        dirname : `str`, default is a chronological name</span>
<span class="sd">            Name of save directory that is appended to savepath where</span>
<span class="sd">            the data of the current model run will be stored.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        All dataframes of the form ``dft_&lt;name&gt;``, if populated,</span>
<span class="sd">        are written to disk in a `.xlsx` extension. The model summary</span>
<span class="sd">        is saved as :py:attr:`~id_` with a `.txt` extension.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            Data that already exists in the target directory will</span>
<span class="sd">            be overwritten with new data. Prevent this by selecting a</span>
<span class="sd">            new directory name or set ``dirname=None`` to automatically</span>
<span class="sd">            generate a chronological directory name which is always unique.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">savepath</span> <span class="o">=</span> <span class="n">savepath</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">savepath</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">savepath</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">savepath</span><span class="p">)</span>

        <span class="c1"># save directory</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dirname</span><span class="p">:</span>
            <span class="c1"># chronological name</span>
            <span class="n">dirname</span> <span class="o">=</span> <span class="n">Time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">%b%Y_%H%M%S&#39;</span><span class="p">,</span> <span class="n">Time</span><span class="o">.</span><span class="n">gmtime</span><span class="p">(</span><span class="n">Time</span><span class="o">.</span><span class="n">time</span><span class="p">()))</span>
            <span class="n">runpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savepath</span><span class="p">,</span> <span class="n">dirname</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">runpath</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># given name</span>
            <span class="n">runpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savepath</span><span class="p">,</span> <span class="n">dirname</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">runpath</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">runpath</span><span class="p">)</span>

        <span class="c1"># write transient dataframes</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># transient dataframes only</span>
            <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;dft_&#39;</span><span class="p">):</span>
                <span class="n">fname</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{k}</span><span class="s2">.xlsx&quot;</span>
                <span class="n">save_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">runpath</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                    <span class="k">with</span> <span class="n">pd</span><span class="o">.</span><span class="n">ExcelWriter</span><span class="p">(</span><span class="n">save_file</span><span class="p">)</span> <span class="k">as</span> <span class="n">fw</span><span class="p">:</span>
                        <span class="n">v</span><span class="o">.</span><span class="n">to_excel</span><span class="p">(</span><span class="n">fw</span><span class="p">,</span> <span class="n">sheet_name</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>

                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="k">with</span> <span class="n">pd</span><span class="o">.</span><span class="n">ExcelWriter</span><span class="p">(</span><span class="n">save_file</span><span class="p">)</span> <span class="k">as</span> <span class="n">fw</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="n">df</span><span class="o">.</span><span class="n">to_excel</span><span class="p">(</span><span class="n">fw</span><span class="p">,</span> <span class="n">sheet_name</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>

        <span class="c1"># write model summary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">runpath</span><span class="p">)</span></div></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">doctest</span>
    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">()</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Bram Berendsen

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>